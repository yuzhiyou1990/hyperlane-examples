import type { SignatureLike } from '@ethersproject/bytes';
import type { BigNumber, ethers } from 'ethers';
export declare enum ProtocolType {
    Ethereum = "ethereum",
    Sealevel = "sealevel",
    Cosmos = "cosmos"
}
export type ProtocolTypeValue = `${ProtocolType}`;
export declare const ProtocolSmallestUnit: {
    ethereum: string;
    sealevel: string;
    cosmos: string;
};
/********* BASIC TYPES *********/
export type Domain = number;
export type EvmChainId = number;
export type ChainId = string | number;
export type Address = string;
export type AddressBytes32 = string;
export type ChainCaip2Id = `${string}:${string}`;
export type TokenCaip19Id = `${string}:${string}/${string}:${string}`;
export type HexString = string;
export type Numberish = number | string | bigint;
export type WithAddress<T> = T & {
    address: Address;
};
export type MerkleProof = {
    branch: ethers.utils.BytesLike[];
    leaf: ethers.utils.BytesLike;
    index: number;
};
/********* HYPERLANE CORE *********/
export type Announcement = {
    mailbox_domain: Domain;
    mailbox_address: Address;
    validator: Address;
    storage_location: string;
};
export type Checkpoint = {
    root: string;
    index: number;
    mailbox_domain: Domain;
    merkle_tree_hook_address: Address;
};
export type CheckpointWithId = {
    checkpoint: Checkpoint;
    message_id: HexString;
};
export { SignatureLike };
/**
 * Shape of a checkpoint in S3 as published by the agent.
 */
export type S3CheckpointWithId = {
    value: CheckpointWithId;
    signature: SignatureLike;
};
export type S3Announcement = {
    value: Announcement;
    signature: SignatureLike;
};
export type S3Checkpoint = {
    value: Checkpoint;
    signature: SignatureLike;
};
export type CallData = {
    to: Address;
    data: string;
    value?: BigNumber;
};
export declare enum MessageStatus {
    NONE = 0,
    PROCESSED = 1
}
export type ParsedMessage = {
    version: number;
    nonce: number;
    origin: number;
    originChain?: string;
    sender: string;
    destination: number;
    destinationChain?: string;
    recipient: string;
    body: string;
};
export type ParsedWarpRouteMessage = {
    recipient: string;
    amount: bigint;
};
export type ParsedLegacyMultisigIsmMetadata = {
    checkpointRoot: string;
    checkpointIndex: number;
    originMailbox: string;
    proof: ethers.utils.BytesLike[];
    signatures: ethers.utils.BytesLike[];
    validators: ethers.utils.BytesLike[];
};
export type Annotated<T> = T & {
    annotation?: string;
};
//# sourceMappingURL=types.d.ts.map
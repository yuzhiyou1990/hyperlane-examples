import { Address, WithAddress } from '@hyperlane-xyz/utils';
import { DispatchedMessage } from '../core/types.js';
import { MultiProvider } from '../providers/MultiProvider.js';
import { ChainNameOrId } from '../types.js';
import { HyperlaneReader } from '../utils/HyperlaneReader.js';
import { AggregationHookConfig, ArbL2ToL1HookConfig, DomainRoutingHookConfig, FallbackRoutingHookConfig, HookConfig, IgpHookConfig, MerkleTreeHookConfig, OnchainHookType, OpStackHookConfig, PausableHookConfig, ProtocolFeeHookConfig } from './types.js';
export type DerivedHookConfig = WithAddress<Exclude<HookConfig, Address>>;
export interface HookReader {
    deriveHookConfig(address: Address): Promise<WithAddress<HookConfig>>;
    deriveMerkleTreeConfig(address: Address): Promise<WithAddress<MerkleTreeHookConfig>>;
    deriveAggregationConfig(address: Address): Promise<WithAddress<AggregationHookConfig>>;
    deriveIgpConfig(address: Address): Promise<WithAddress<IgpHookConfig>>;
    deriveProtocolFeeConfig(address: Address): Promise<WithAddress<ProtocolFeeHookConfig>>;
    deriveOpStackConfig(address: Address): Promise<WithAddress<OpStackHookConfig>>;
    deriveArbL2ToL1Config(address: Address): Promise<WithAddress<ArbL2ToL1HookConfig>>;
    deriveDomainRoutingConfig(address: Address): Promise<WithAddress<DomainRoutingHookConfig>>;
    deriveFallbackRoutingConfig(address: Address): Promise<WithAddress<FallbackRoutingHookConfig>>;
    derivePausableConfig(address: Address): Promise<WithAddress<PausableHookConfig>>;
    assertHookType(hookType: OnchainHookType, expectedType: OnchainHookType): void;
}
export declare class EvmHookReader extends HyperlaneReader implements HookReader {
    protected readonly multiProvider: MultiProvider;
    protected readonly chain: ChainNameOrId;
    protected readonly concurrency: number;
    protected readonly messageContext?: DispatchedMessage | undefined;
    protected readonly logger: import("pino").default.Logger<never>;
    /**
     * HookConfig cache for already retrieved configs. Useful to avoid recomputing configs
     * when they have already been retrieved in previous calls where `deriveHookConfig` was called by
     * the specific hook methods.
     */
    private _cache;
    constructor(multiProvider: MultiProvider, chain: ChainNameOrId, concurrency?: number, messageContext?: DispatchedMessage | undefined);
    deriveHookConfig(address: Address): Promise<DerivedHookConfig>;
    deriveMerkleTreeConfig(address: Address): Promise<WithAddress<MerkleTreeHookConfig>>;
    deriveAggregationConfig(address: Address): Promise<WithAddress<AggregationHookConfig>>;
    deriveIgpConfig(address: Address): Promise<WithAddress<IgpHookConfig>>;
    deriveProtocolFeeConfig(address: Address): Promise<WithAddress<ProtocolFeeHookConfig>>;
    deriveOpStackConfig(address: Address): Promise<WithAddress<OpStackHookConfig>>;
    deriveArbL2ToL1Config(address: Address): Promise<WithAddress<ArbL2ToL1HookConfig>>;
    deriveDomainRoutingConfig(address: Address): Promise<WithAddress<DomainRoutingHookConfig>>;
    deriveFallbackRoutingConfig(address: Address): Promise<WithAddress<FallbackRoutingHookConfig>>;
    private fetchDomainHooks;
    derivePausableConfig(address: Address): Promise<WithAddress<PausableHookConfig>>;
    assertHookType(hookType: OnchainHookType, expectedType: OnchainHookType): void;
}
//# sourceMappingURL=EvmHookReader.d.ts.map
import { ethers } from 'ethers';
import { ArbL2ToL1Hook, DomainRoutingHook, InterchainGasPaymaster, OPStackHook, PausableHook, ProtocolFee, StaticAggregationHook, StorageGasOracle } from '@hyperlane-xyz/core';
import { Address, Domain, EvmChainId, ProtocolType } from '@hyperlane-xyz/utils';
import { HyperlaneAddresses } from '../contracts/types.js';
import { HyperlaneModule, HyperlaneModuleParams } from '../core/AbstractHyperlaneModule.js';
import { CoreAddresses } from '../core/contracts.js';
import { HyperlaneDeployer } from '../deploy/HyperlaneDeployer.js';
import { ProxyFactoryFactories } from '../deploy/contracts.js';
import { ContractVerifier } from '../deploy/verify/ContractVerifier.js';
import { IgpConfig } from '../gas/types.js';
import { HyperlaneIsmFactory } from '../ism/HyperlaneIsmFactory.js';
import { MultiProvider } from '../providers/MultiProvider.js';
import { AnnotatedEV5Transaction } from '../providers/ProviderType.js';
import { ChainName, ChainNameOrId } from '../types.js';
import { EvmHookReader } from './EvmHookReader.js';
import { DeployedHook, HookFactories } from './contracts.js';
import { AggregationHookConfig, ArbL2ToL1HookConfig, DomainRoutingHookConfig, FallbackRoutingHookConfig, HookConfig, IgpHookConfig, OpStackHookConfig, PausableHookConfig, ProtocolFeeHookConfig } from './types.js';
type HookModuleAddresses = {
    deployedHook: Address;
    mailbox: Address;
    proxyAdmin: Address;
};
declare class HookDeployer extends HyperlaneDeployer<{}, HookFactories> {
    protected cachingEnabled: boolean;
    deployContracts(_chain: ChainName, _config: {}): Promise<any>;
}
export declare class EvmHookModule extends HyperlaneModule<ProtocolType.Ethereum, HookConfig, HyperlaneAddresses<ProxyFactoryFactories> & HookModuleAddresses> {
    protected readonly multiProvider: MultiProvider;
    protected readonly contractVerifier?: ContractVerifier | undefined;
    protected readonly logger: import("pino").default.Logger<never>;
    protected readonly reader: EvmHookReader;
    protected readonly hookFactory: HyperlaneIsmFactory;
    protected readonly deployer: HookDeployer;
    readonly chain: ChainName;
    readonly chainId: EvmChainId;
    readonly domainId: Domain;
    protected readonly txOverrides: Partial<ethers.providers.TransactionRequest>;
    protected constructor(multiProvider: MultiProvider, params: HyperlaneModuleParams<HookConfig, HyperlaneAddresses<ProxyFactoryFactories> & HookModuleAddresses>, contractVerifier?: ContractVerifier | undefined);
    read(): Promise<HookConfig>;
    update(targetConfig: HookConfig): Promise<AnnotatedEV5Transaction[]>;
    static create({ chain, config, proxyFactoryFactories, coreAddresses, multiProvider, contractVerifier, }: {
        chain: ChainNameOrId;
        config: HookConfig;
        proxyFactoryFactories: HyperlaneAddresses<ProxyFactoryFactories>;
        coreAddresses: CoreAddresses;
        multiProvider: MultiProvider;
        contractVerifier?: ContractVerifier;
    }): Promise<EvmHookModule>;
    protected computeRoutingHooksToSet({ currentDomains, targetDomains, }: {
        currentDomains: DomainRoutingHookConfig['domains'];
        targetDomains: DomainRoutingHookConfig['domains'];
    }): Promise<DomainRoutingHook.HookConfigStruct[]>;
    protected updatePausableHook({ currentConfig, targetConfig, }: {
        currentConfig: PausableHookConfig;
        targetConfig: PausableHookConfig;
    }): Promise<AnnotatedEV5Transaction[]>;
    protected updateIgpHook({ currentConfig, targetConfig, }: {
        currentConfig: IgpHookConfig;
        targetConfig: IgpHookConfig;
    }): Promise<AnnotatedEV5Transaction[]>;
    protected updateIgpRemoteGasParams({ interchainGasPaymaster, gasOracle, currentOverheads, targetOverheads, }: {
        interchainGasPaymaster: Address;
        gasOracle: Address;
        currentOverheads?: IgpConfig['overhead'];
        targetOverheads: IgpConfig['overhead'];
    }): Promise<AnnotatedEV5Transaction[]>;
    protected updateStorageGasOracle({ gasOracle, currentOracleConfig, targetOracleConfig, targetOverhead, }: {
        gasOracle: Address;
        currentOracleConfig?: IgpConfig['oracleConfig'];
        targetOracleConfig: IgpConfig['oracleConfig'];
        targetOverhead: IgpConfig['overhead'];
    }): Promise<AnnotatedEV5Transaction[]>;
    protected updateProtocolFeeHook({ currentConfig, targetConfig, }: {
        currentConfig: ProtocolFeeHookConfig;
        targetConfig: ProtocolFeeHookConfig;
    }): Promise<AnnotatedEV5Transaction[]>;
    protected updateRoutingHook({ currentConfig, targetConfig, }: {
        currentConfig: DomainRoutingHookConfig | FallbackRoutingHookConfig;
        targetConfig: DomainRoutingHookConfig | FallbackRoutingHookConfig;
    }): Promise<AnnotatedEV5Transaction[]>;
    protected deploy({ config, }: {
        config: HookConfig;
    }): Promise<DeployedHook>;
    protected deployProtocolFeeHook({ config, }: {
        config: ProtocolFeeHookConfig;
    }): Promise<ProtocolFee>;
    protected deployPausableHook({ config, }: {
        config: PausableHookConfig;
    }): Promise<PausableHook>;
    protected deployAggregationHook({ config, }: {
        config: AggregationHookConfig;
    }): Promise<StaticAggregationHook>;
    protected deployOpStackHook({ config, }: {
        config: OpStackHookConfig;
    }): Promise<OPStackHook>;
    protected deployArbL1ToL1Hook({ config, }: {
        config: ArbL2ToL1HookConfig;
    }): Promise<ArbL2ToL1Hook>;
    protected deployRoutingHook({ config, }: {
        config: DomainRoutingHookConfig | FallbackRoutingHookConfig;
    }): Promise<DomainRoutingHook>;
    protected deployIgpHook({ config, }: {
        config: IgpHookConfig;
    }): Promise<InterchainGasPaymaster>;
    protected deployInterchainGasPaymaster({ storageGasOracle, config, }: {
        storageGasOracle: StorageGasOracle;
        config: IgpConfig;
    }): Promise<InterchainGasPaymaster>;
    protected deployStorageGasOracle({ config, }: {
        config: IgpConfig;
    }): Promise<StorageGasOracle>;
    /**
     * Determines if a new hook should be deployed based on the current and target configurations.
     *
     * @param currentConfig - The current hook configuration.
     * @param targetConfig - The target hook configuration. Must not be a string.
     * @returns {boolean} - Returns true if a new hook should be deployed, otherwise false.
     *
     * Conditions for deploying a new hook:
     * - If updating from an address/custom config to a proper hook config.
     * - If updating a proper hook config whose types are different.
     * - If it is not a mutable Hook.
     */
    private shouldDeployNewHook;
}
export {};
//# sourceMappingURL=EvmHookModule.d.ts.map
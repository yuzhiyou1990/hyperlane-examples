/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */
export type TokenModeMsgForCw20ModeBridgedAndCw20ModeCollateral = {
    bridged: Cw20ModeBridged;
} | {
    collateral: Cw20ModeCollateral;
};
export type Uint128 = string;
export type Logo = {
    url: string;
} | {
    embedded: EmbeddedLogo;
};
export type EmbeddedLogo = {
    svg: Binary;
} | {
    png: Binary;
};
export type Binary = string;
export interface InstantiateMsg {
    hrp: string;
    mailbox: string;
    owner: string;
    token: TokenModeMsgForCw20ModeBridgedAndCw20ModeCollateral;
}
export interface Cw20ModeBridged {
    code_id: number;
    init_msg: InstantiateMsg1;
}
export interface InstantiateMsg1 {
    decimals: number;
    initial_balances: Cw20Coin[];
    marketing?: InstantiateMarketingInfo | null;
    mint?: MinterResponse | null;
    name: string;
    symbol: string;
}
export interface Cw20Coin {
    address: string;
    amount: Uint128;
}
export interface InstantiateMarketingInfo {
    description?: string | null;
    logo?: Logo | null;
    marketing?: string | null;
    project?: string | null;
}
export interface MinterResponse {
    cap?: Uint128 | null;
    minter: string;
}
export interface Cw20ModeCollateral {
    address: string;
}
export type ExecuteMsg = {
    ownable: OwnableMsg;
} | {
    router: RouterMsgForHexBinary;
} | {
    connection: ConnectionMsg;
} | {
    handle: HandleMsg;
} | {
    transfer_remote: {
        amount: Uint128;
        dest_domain: number;
        recipient: HexBinary;
    };
};
export type OwnableMsg = {
    init_ownership_transfer: {
        next_owner: string;
    };
} | {
    revoke_ownership_transfer: {};
} | {
    claim_ownership: {};
};
export type RouterMsgForHexBinary = {
    set_route: {
        set: DomainRouteSetForHexBinary;
    };
} | {
    set_routes: {
        set: DomainRouteSetForHexBinary[];
    };
};
export type HexBinary = string;
export type ConnectionMsg = {
    set_mailbox: {
        mailbox: string;
    };
} | {
    set_hook: {
        hook: string;
    };
} | {
    set_ism: {
        ism: string;
    };
};
export interface DomainRouteSetForHexBinary {
    domain: number;
    route?: HexBinary | null;
}
export interface HandleMsg {
    body: HexBinary;
    origin: number;
    sender: HexBinary;
}
export type QueryMsg = {
    ownable: OwnableQueryMsg;
} | {
    router: RouterQueryForHexBinary;
} | {
    connection: ConnectionQueryMsg;
} | {
    token_default: TokenWarpDefaultQueryMsg;
} | {
    ism_specifier: IsmSpecifierQueryMsg;
};
export type OwnableQueryMsg = {
    get_owner: {};
} | {
    get_pending_owner: {};
};
export type RouterQueryForHexBinary = {
    domains: {};
} | {
    get_route: {
        domain: number;
    };
} | {
    list_routes: {
        limit?: number | null;
        offset?: number | null;
        order?: Order | null;
    };
};
export type Order = 'asc' | 'desc';
export type ConnectionQueryMsg = {
    get_mailbox: {};
} | {
    get_hook: {};
} | {
    get_ism: {};
};
export type TokenWarpDefaultQueryMsg = {
    token_type: {};
} | {
    token_mode: {};
};
export type IsmSpecifierQueryMsg = {
    interchain_security_module: [];
};
export interface DomainsResponse {
    domains: number[];
}
export interface HookResponse {
    hook?: string | null;
}
export interface IsmResponse {
    ism?: string | null;
}
export interface MailboxResponse {
    mailbox?: string | null;
}
export type Addr = string;
export interface OwnerResponse {
    owner: Addr;
}
export interface PendingOwnerResponse {
    pending_owner?: Addr | null;
}
export interface RouteResponseForHexBinary {
    route: DomainRouteSetForHexBinary;
}
export interface InterchainSecurityModuleResponse {
    ism?: Addr | null;
}
export interface RoutesResponseForHexBinary {
    routes: DomainRouteSetForHexBinary[];
}
export interface Empty {
    [k: string]: unknown;
}
export type TokenMode = 'bridged' | 'collateral';
export interface TokenModeResponse {
    mode: TokenMode;
}
export type TokenType = {
    native: TokenTypeNative;
} | {
    c_w20: {
        contract: string;
    };
} | {
    c_w721: {
        contract: string;
    };
};
export type TokenTypeNative = {
    fungible: {
        denom: string;
    };
} | {
    non_fungible: {
        class: string;
    };
};
export interface TokenTypeResponse {
    type: TokenType;
}
//# sourceMappingURL=WarpCw20.types.d.ts.map
import { ethers } from 'ethers';
import { addressToBytes32, assert, eqAddress, rootLogger, } from '@hyperlane-xyz/utils';
import { HyperlaneAppChecker } from '../deploy/HyperlaneAppChecker.js';
import { EvmIsmReader } from '../ism/EvmIsmReader.js';
import { moduleMatchesConfig } from '../ism/utils.js';
import { ClientViolationType, RouterViolationType, } from './types.js';
export class HyperlaneRouterChecker extends HyperlaneAppChecker {
    ismFactory;
    logger;
    constructor(multiProvider, app, configMap, ismFactory, logger = rootLogger.child({ module: 'HyperlaneRouterChecker' })) {
        super(multiProvider, app, configMap);
        this.ismFactory = ismFactory;
        this.logger = logger;
    }
    async checkChain(chain) {
        await this.checkMailboxClient(chain);
        await this.checkEnrolledRouters(chain);
        await super.checkOwnership(chain, this.configMap[chain].owner, this.configMap[chain].ownerOverrides);
    }
    async checkMailboxClient(chain) {
        const router = this.app.router(this.app.getContracts(chain));
        const config = this.configMap[chain];
        const mailboxAddr = await router.mailbox();
        if (!eqAddress(mailboxAddr, config.mailbox)) {
            this.addViolation({
                chain,
                type: ClientViolationType.Mailbox,
                contract: router,
                actual: mailboxAddr,
                expected: config.mailbox,
            });
        }
        if (config.hook) {
            assert(typeof config.hook === 'string', 'Hook objects not supported in router checker');
            const hook = await router.hook();
            if (!eqAddress(hook, config.hook)) {
                this.addViolation({
                    chain,
                    type: ClientViolationType.Hook,
                    contract: router,
                    actual: hook,
                    expected: config.hook,
                });
            }
        }
        const actualIsmAddress = await router.interchainSecurityModule();
        const matches = await moduleMatchesConfig(chain, actualIsmAddress, config.interchainSecurityModule ?? ethers.constants.AddressZero, this.multiProvider, this.ismFactory?.chainMap[chain] ?? {}, mailboxAddr);
        if (!matches) {
            const ismReader = new EvmIsmReader(this.multiProvider, chain);
            let actualConfig = ethers.constants.AddressZero;
            if (actualIsmAddress !== ethers.constants.AddressZero) {
                actualConfig = await ismReader.deriveIsmConfig(actualIsmAddress);
            }
            let expectedConfig = config.interchainSecurityModule;
            if (typeof expectedConfig === 'string') {
                expectedConfig = await ismReader.deriveIsmConfig(expectedConfig);
            }
            if (expectedConfig === undefined) {
                expectedConfig = ethers.constants.AddressZero;
            }
            const violation = {
                chain,
                type: ClientViolationType.InterchainSecurityModule,
                contract: router,
                actual: actualConfig,
                expected: expectedConfig,
                description: `ISM config does not match deployed ISM`,
            };
            this.addViolation(violation);
        }
    }
    async checkEnrolledRouters(chain) {
        const router = this.app.router(this.app.getContracts(chain));
        const remoteChains = await this.app.remoteChains(chain);
        const currentRouters = {};
        const expectedRouters = {};
        const routerDiff = {};
        await Promise.all(remoteChains.map(async (remoteChain) => {
            const remoteRouterAddress = this.app.routerAddress(remoteChain);
            const remoteDomainId = this.multiProvider.getDomainId(remoteChain);
            const actualRouter = await router.routers(remoteDomainId);
            const expectedRouter = addressToBytes32(remoteRouterAddress);
            currentRouters[remoteChain] = actualRouter;
            expectedRouters[remoteChain] = expectedRouter;
            if (actualRouter !== expectedRouter) {
                routerDiff[remoteChain] = {
                    actual: actualRouter,
                    expected: expectedRouter,
                };
            }
        }));
        if (Object.keys(routerDiff).length > 0) {
            const violation = {
                chain,
                type: RouterViolationType.EnrolledRouter,
                contract: router,
                actual: currentRouters,
                expected: expectedRouters,
                routerDiff,
                description: `Routers for some domains are missing or not enrolled correctly`,
            };
            this.addViolation(violation);
        }
    }
}
//# sourceMappingURL=HyperlaneRouterChecker.js.map
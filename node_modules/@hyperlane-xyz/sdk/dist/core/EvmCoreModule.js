import { Mailbox__factory, Ownable__factory, } from '@hyperlane-xyz/core';
import { eqAddress, rootLogger, } from '@hyperlane-xyz/utils';
import { attachContractsMap, serializeContractsMap, transferOwnershipTransactions, } from '../contracts/contracts.js';
import { HyperlaneProxyFactoryDeployer } from '../deploy/HyperlaneProxyFactoryDeployer.js';
import { proxyFactoryFactories, } from '../deploy/contracts.js';
import { proxyAdminUpdateTxs } from '../deploy/proxy.js';
import { EvmIsmModule } from '../ism/EvmIsmModule.js';
import { HyperlaneIsmFactory } from '../ism/HyperlaneIsmFactory.js';
import { HyperlaneModule, } from './AbstractHyperlaneModule.js';
import { EvmCoreReader } from './EvmCoreReader.js';
import { EvmIcaModule } from './EvmIcaModule.js';
import { HyperlaneCoreDeployer } from './HyperlaneCoreDeployer.js';
import { CoreConfigSchema } from './schemas.js';
export class EvmCoreModule extends HyperlaneModule {
    multiProvider;
    logger = rootLogger.child({ module: 'EvmCoreModule' });
    coreReader;
    chainName;
    chainId;
    domainId;
    constructor(multiProvider, args) {
        super(args);
        this.multiProvider = multiProvider;
        this.coreReader = new EvmCoreReader(multiProvider, args.chain);
        this.chainName = multiProvider.getChainName(args.chain);
        this.chainId = multiProvider.getEvmChainId(args.chain);
        this.domainId = multiProvider.getDomainId(args.chain);
        this.chainId = multiProvider.getEvmChainId(args.chain);
    }
    /**
     * Reads the core configuration from the mailbox address specified in the SDK arguments.
     * @returns The core config.
     */
    async read() {
        return this.coreReader.deriveCoreConfig(this.args.addresses.mailbox);
    }
    /**
     * Updates the core contracts with the provided configuration.
     *
     * @param expectedConfig - The configuration for the core contracts to be updated.
     * @returns An array of Ethereum transactions that were executed to update the contract.
     */
    async update(expectedConfig) {
        CoreConfigSchema.parse(expectedConfig);
        const actualConfig = await this.read();
        const transactions = [];
        transactions.push(...(await this.createDefaultIsmUpdateTxs(actualConfig, expectedConfig)), ...this.createMailboxOwnerUpdateTxs(actualConfig, expectedConfig), ...proxyAdminUpdateTxs(this.chainId, this.args.addresses.mailbox, actualConfig, expectedConfig));
        return transactions;
    }
    /**
     * Create a transaction to update an existing ISM config, or deploy a new ISM and return a tx to setDefaultIsm
     *
     * @param actualConfig - The on-chain router configuration, including the ISM configuration, and address.
     * @param expectedConfig - The expected token router configuration, including the ISM configuration.
     * @returns Transaction that need to be executed to update the ISM configuration.
     */
    async createDefaultIsmUpdateTxs(actualConfig, expectedConfig) {
        const updateTransactions = [];
        const actualDefaultIsmConfig = actualConfig.defaultIsm;
        // Try to update (may also deploy) Ism with the expected config
        const { deployedIsm, ismUpdateTxs } = await this.deployOrUpdateIsm(actualDefaultIsmConfig, expectedConfig.defaultIsm);
        if (ismUpdateTxs.length) {
            updateTransactions.push(...ismUpdateTxs);
        }
        const newIsmDeployed = !eqAddress(actualDefaultIsmConfig.address, deployedIsm);
        if (newIsmDeployed) {
            const { mailbox } = this.serialize();
            const contractToUpdate = Mailbox__factory.connect(mailbox, this.multiProvider.getProvider(this.domainId));
            updateTransactions.push({
                annotation: `Setting default ISM for Mailbox ${mailbox} to ${deployedIsm}`,
                chainId: this.chainId,
                to: contractToUpdate.address,
                data: contractToUpdate.interface.encodeFunctionData('setDefaultIsm', [
                    deployedIsm,
                ]),
            });
        }
        return updateTransactions;
    }
    /**
     * Updates or deploys the ISM using the provided configuration.
     *
     * @returns Object with deployedIsm address, and update Transactions
     */
    async deployOrUpdateIsm(actualDefaultIsmConfig, expectDefaultIsmConfig) {
        const { mailbox, domainRoutingIsmFactory, staticAggregationIsmFactory, staticAggregationHookFactory, staticMessageIdMultisigIsmFactory, staticMerkleRootMultisigIsmFactory, staticMerkleRootWeightedMultisigIsmFactory, staticMessageIdWeightedMultisigIsmFactory, } = this.serialize();
        const ismModule = new EvmIsmModule(this.multiProvider, {
            chain: this.args.chain,
            config: expectDefaultIsmConfig,
            addresses: {
                mailbox,
                domainRoutingIsmFactory,
                staticAggregationIsmFactory,
                staticAggregationHookFactory,
                staticMessageIdMultisigIsmFactory,
                staticMerkleRootMultisigIsmFactory,
                staticMerkleRootWeightedMultisigIsmFactory,
                staticMessageIdWeightedMultisigIsmFactory,
                deployedIsm: actualDefaultIsmConfig.address,
            },
        });
        this.logger.info(`Comparing target ISM config with ${this.args.chain} chain`);
        const ismUpdateTxs = await ismModule.update(expectDefaultIsmConfig);
        const { deployedIsm } = ismModule.serialize();
        return { deployedIsm, ismUpdateTxs };
    }
    /**
     * Create a transaction to transfer ownership of an existing mailbox with a given config.
     *
     * @param actualConfig - The on-chain core configuration.
     * @param expectedConfig - The expected token core configuration.
     * @returns Ethereum transaction that need to be executed to update the owner.
     */
    createMailboxOwnerUpdateTxs(actualConfig, expectedConfig) {
        return transferOwnershipTransactions(this.chainId, this.args.addresses.mailbox, actualConfig, expectedConfig, 'Mailbox');
    }
    /**
     * Deploys the Core contracts.
     * @remark Most of the contract owners is the Deployer with some being the Proxy Admin.
     * @returns The created EvmCoreModule instance.
     */
    static async create(params) {
        const { chain, config, multiProvider, contractVerifier } = params;
        const addresses = await EvmCoreModule.deploy({
            config,
            multiProvider,
            chain,
            contractVerifier,
        });
        // Create CoreModule and deploy the Core contracts
        const module = new EvmCoreModule(multiProvider, {
            addresses,
            chain,
            config,
        });
        return module;
    }
    /**
     * Deploys the core Hyperlane contracts.
     * @returns The deployed core contract addresses.
     */
    static async deploy(params) {
        const { config, multiProvider, chain, contractVerifier } = params;
        const chainName = multiProvider.getChainName(chain);
        const ismFactoryFactories = await EvmCoreModule.deployIsmFactories({
            chainName,
            config,
            multiProvider,
            contractVerifier,
        });
        const ismFactory = new HyperlaneIsmFactory(attachContractsMap({ [chainName]: ismFactoryFactories }, proxyFactoryFactories), multiProvider);
        const coreDeployer = new HyperlaneCoreDeployer(multiProvider, ismFactory, contractVerifier);
        // Deploy proxyAdmin
        const proxyAdmin = await coreDeployer.deployContract(chainName, 'proxyAdmin', []);
        // Deploy Mailbox
        const mailbox = await this.deployMailbox({
            config,
            coreDeployer,
            proxyAdmin: proxyAdmin.address,
            multiProvider,
            chain,
        });
        // Deploy ICA ISM and Router
        const { interchainAccountRouter, interchainAccountIsm } = (await EvmIcaModule.create({
            chain: chainName,
            multiProvider: multiProvider,
            config: {
                mailbox: mailbox.address,
                owner: await multiProvider.getSigner(chain).getAddress(),
            },
            contractVerifier,
        })).serialize();
        // Deploy Validator announce
        const validatorAnnounce = (await coreDeployer.deployValidatorAnnounce(chainName, mailbox.address)).address;
        // Deploy timelock controller if config.upgrade is set
        let timelockController;
        if (config.upgrade) {
            timelockController = (await coreDeployer.deployTimelock(chainName, config.upgrade.timelock)).address;
        }
        // Deploy Test Recipient
        const testRecipient = (await coreDeployer.deployTestRecipient(chainName, await mailbox.defaultIsm())).address;
        // Obtain addresses of every contract created by the deployer
        // and extract only the merkleTreeHook and interchainGasPaymaster
        const serializedContracts = serializeContractsMap(coreDeployer.deployedContracts);
        const { merkleTreeHook, interchainGasPaymaster } = serializedContracts[chainName];
        // Update the ProxyAdmin owner of the Mailbox if the config defines a different owner from the current signer
        const currentProxyOwner = await proxyAdmin.owner();
        if (config?.proxyAdmin?.owner &&
            !eqAddress(config.proxyAdmin.owner, currentProxyOwner)) {
            await multiProvider.sendTransaction(chainName, {
                annotation: `Transferring ownership of ProxyAdmin to the configured address ${config.proxyAdmin.owner}`,
                to: proxyAdmin.address,
                data: Ownable__factory.createInterface().encodeFunctionData('transferOwnership(address)', [config.proxyAdmin.owner]),
            });
        }
        // Set Core & extra addresses
        return {
            ...ismFactoryFactories,
            proxyAdmin: proxyAdmin.address,
            mailbox: mailbox.address,
            interchainAccountRouter,
            interchainAccountIsm,
            validatorAnnounce,
            timelockController,
            testRecipient,
            merkleTreeHook,
            interchainGasPaymaster,
        };
    }
    /**
     * Deploys the ISM factories for a given chain.
     * @returns The deployed ISM factories addresses.
     */
    static async deployIsmFactories(params) {
        const { chainName, config, multiProvider, contractVerifier } = params;
        const proxyFactoryDeployer = new HyperlaneProxyFactoryDeployer(multiProvider, contractVerifier);
        const ismFactoriesFactory = await proxyFactoryDeployer.deploy({
            [chainName]: config,
        });
        return serializeContractsMap(ismFactoriesFactory)[chainName];
    }
    /**
     * Deploys a Mailbox and its default ISM, hook, and required hook contracts with a given configuration.
     * @returns The deployed Mailbox contract instance.
     */
    static async deployMailbox(params) {
        const { config, proxyAdmin, coreDeployer: deployer, multiProvider, chain, } = params;
        const chainName = multiProvider.getChainName(chain);
        const domain = multiProvider.getDomainId(chainName);
        const mailbox = await deployer.deployProxiedContract(chainName, 'mailbox', 'mailbox', proxyAdmin, [domain]);
        // @todo refactor when 1) IsmModule is ready
        const deployedDefaultIsm = await deployer.deployIsm(chainName, config.defaultIsm, mailbox.address);
        // @todo refactor when 1) HookModule is ready, and 2) Hooks Config can handle strings
        const deployedDefaultHook = await deployer.deployHook(chainName, config.defaultHook, {
            mailbox: mailbox.address,
            proxyAdmin,
        });
        // @todo refactor when 1) HookModule is ready, and 2) Hooks Config can handle strings
        const deployedRequiredHook = await deployer.deployHook(chainName, config.requiredHook, {
            mailbox: mailbox.address,
            proxyAdmin,
        });
        // Initialize Mailbox
        await multiProvider.handleTx(chain, mailbox.initialize(config.owner, deployedDefaultIsm, deployedDefaultHook.address, deployedRequiredHook.address, multiProvider.getTransactionOverrides(chain)));
        return mailbox;
    }
}
//# sourceMappingURL=EvmCoreModule.js.map
import { ProtocolType, rootLogger } from '@hyperlane-xyz/utils';
import { MultiProtocolApp } from '../app/MultiProtocolApp.js';
import { CosmWasmCoreAdapter } from './adapters/CosmWasmCoreAdapter.js';
import { EvmCoreAdapter } from './adapters/EvmCoreAdapter.js';
import { SealevelCoreAdapter } from './adapters/SealevelCoreAdapter.js';
export class MultiProtocolCore extends MultiProtocolApp {
    multiProvider;
    addresses;
    logger;
    constructor(multiProvider, addresses, logger = rootLogger.child({ module: 'MultiProtocolCore' })) {
        super(multiProvider, addresses, logger);
        this.multiProvider = multiProvider;
        this.addresses = addresses;
        this.logger = logger;
    }
    static fromAddressesMap(addressesMap, multiProvider) {
        return new MultiProtocolCore(multiProvider.intersect(Object.keys(addressesMap)).result, addressesMap);
    }
    protocolToAdapter(protocol) {
        if (protocol === ProtocolType.Ethereum)
            return EvmCoreAdapter;
        if (protocol === ProtocolType.Sealevel)
            return SealevelCoreAdapter;
        if (protocol === ProtocolType.Cosmos)
            return CosmWasmCoreAdapter;
        throw new Error(`No adapter for protocol ${protocol}`);
    }
    extractMessageIds(origin, sourceTx) {
        return this.adapter(origin).extractMessageIds(sourceTx);
    }
    async waitForMessagesProcessed(origin, destination, sourceTx, delayMs, maxAttempts) {
        const messages = this.adapter(origin).extractMessageIds(sourceTx);
        await Promise.all(messages.map((msg) => this.adapter(destination).waitForMessageProcessed(msg.messageId, msg.destination, delayMs, maxAttempts)));
        return true;
    }
}
//# sourceMappingURL=MultiProtocolCore.js.map
import { TransactionReceipt } from '@ethersproject/providers';
import { ethers } from 'ethers';
import type { TransactionReceipt as ViemTxReceipt } from 'viem';
import { IMessageRecipient } from '@hyperlane-xyz/core';
import { Address, AddressBytes32 } from '@hyperlane-xyz/utils';
import { HyperlaneApp } from '../app/HyperlaneApp.js';
import { HyperlaneAddressesMap } from '../contracts/types.js';
import { OwnableConfig } from '../deploy/types.js';
import { DerivedHookConfig } from '../hook/EvmHookReader.js';
import { DerivedIsmConfig } from '../ism/EvmIsmReader.js';
import { MultiProvider } from '../providers/MultiProvider.js';
import { RouterConfig } from '../router/types.js';
import { ChainMap, ChainName } from '../types.js';
import { CoreFactories } from './contracts.js';
import { DispatchEvent } from './events.js';
import { DispatchedMessage } from './types.js';
export declare class HyperlaneCore extends HyperlaneApp<CoreFactories> {
    static fromAddressesMap(addressesMap: HyperlaneAddressesMap<any>, multiProvider: MultiProvider): HyperlaneCore;
    getRouterConfig: (owners: Address | ChainMap<OwnableConfig>) => ChainMap<RouterConfig>;
    quoteGasPayment: (origin: ChainName, destination: ChainName, recipient: AddressBytes32, body: string, metadata?: string, hook?: Address) => Promise<ethers.BigNumber>;
    getDestination(message: DispatchedMessage): ChainName;
    getOrigin(message: DispatchedMessage): ChainName;
    getRecipientIsmAddress(message: DispatchedMessage): Promise<Address>;
    getHookAddress(message: DispatchedMessage): Promise<Address>;
    getRecipientIsmConfig(message: DispatchedMessage): Promise<DerivedIsmConfig>;
    getHookConfig(message: DispatchedMessage): Promise<DerivedHookConfig>;
    sendMessage(origin: ChainName, destination: ChainName, recipient: Address, body: string, hook?: Address, metadata?: string): Promise<{
        dispatchTx: TransactionReceipt;
        message: DispatchedMessage;
    }>;
    onDispatch(handler: (message: DispatchedMessage, event: DispatchEvent) => Promise<void>, chains?: string[]): {
        removeHandler: (chains?: ChainName[]) => void;
    };
    getDefaults(): Promise<ChainMap<{
        ism: Address;
        hook: Address;
    }>>;
    getIsm(destinationChain: ChainName, recipientAddress: Address): Promise<Address>;
    protected getRecipient(message: DispatchedMessage): IMessageRecipient;
    estimateHandle(message: DispatchedMessage): Promise<string>;
    deliver(message: DispatchedMessage, ismMetadata: string): Promise<ethers.ContractReceipt>;
    getHook(originChain: ChainName, senderAddress: Address): Promise<Address>;
    isDelivered(message: DispatchedMessage): Promise<boolean>;
    getSenderHookAddress(message: DispatchedMessage): Promise<Address>;
    getProcessedReceipt(message: DispatchedMessage): Promise<ethers.ContractReceipt>;
    protected waitForProcessReceipt(message: DispatchedMessage): Promise<ethers.ContractReceipt>;
    waitForMessageIdProcessed(messageId: string, destination: ChainName, delayMs?: number, maxAttempts?: number): Promise<true>;
    waitForMessageProcessing(sourceTx: ethers.ContractReceipt | ViemTxReceipt): Promise<ethers.ContractReceipt[]>;
    waitForMessageProcessed(sourceTx: ethers.ContractReceipt | ViemTxReceipt, delay?: number, maxAttempts?: number): Promise<void>;
    getDispatchedMessages(sourceTx: TransactionReceipt | ViemTxReceipt): DispatchedMessage[];
    getDispatchTx(originChain: ChainName, messageId: string, blockNumber?: number): Promise<TransactionReceipt>;
    static parseDispatchedMessage(message: string): DispatchedMessage;
    static getDispatchedMessages(sourceTx: TransactionReceipt | ViemTxReceipt): DispatchedMessage[];
}
//# sourceMappingURL=HyperlaneCore.d.ts.map
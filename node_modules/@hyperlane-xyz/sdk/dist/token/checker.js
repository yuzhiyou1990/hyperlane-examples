import { BigNumber } from 'ethers';
import { ERC20__factory, IXERC20Lockbox__factory, } from '@hyperlane-xyz/core';
import { eqAddress } from '@hyperlane-xyz/utils';
import { ProxiedRouterChecker } from '../router/ProxiedRouterChecker.js';
import { TokenType } from './config.js';
import { isCollateralConfig, isNativeConfig, isSyntheticConfig, } from './schemas.js';
export class HypERC20Checker extends ProxiedRouterChecker {
    async checkChain(chain) {
        await super.checkChain(chain);
        await this.checkToken(chain);
    }
    async checkToken(chain) {
        const checkERC20 = async (token, config) => {
            const checks = [
                { method: 'symbol', violationType: 'TokenSymbolMismatch' },
                { method: 'name', violationType: 'TokenNameMismatch' },
                { method: 'decimals', violationType: 'TokenDecimalsMismatch' },
            ];
            for (const check of checks) {
                const actual = await token[check.method]();
                const expected = config[check.method];
                if (expected !== undefined && actual !== expected) {
                    const violation = {
                        type: check.violationType,
                        chain,
                        expected,
                        actual,
                        tokenAddress: token.address,
                    };
                    this.addViolation(violation);
                }
            }
        };
        const expectedConfig = this.configMap[chain];
        const hypToken = this.app.router(this.app.getContracts(chain));
        if (isNativeConfig(expectedConfig)) {
            try {
                await this.multiProvider.estimateGas(chain, {
                    to: hypToken.address,
                    from: await this.multiProvider.getSignerAddress(chain),
                    value: BigNumber.from(1),
                });
            }
            catch {
                const violation = {
                    type: 'deployed token not payable',
                    chain,
                    expected: 'true',
                    actual: 'false',
                    tokenAddress: hypToken.address,
                };
                this.addViolation(violation);
            }
        }
        else if (isSyntheticConfig(expectedConfig)) {
            await checkERC20(hypToken, expectedConfig);
        }
        else if (isCollateralConfig(expectedConfig)) {
            const provider = this.multiProvider.getProvider(chain);
            let collateralToken;
            if (expectedConfig.type === TokenType.XERC20Lockbox) {
                const collateralTokenAddress = await IXERC20Lockbox__factory.connect(expectedConfig.token, provider).callStatic.ERC20();
                collateralToken = await ERC20__factory.connect(collateralTokenAddress, provider);
            }
            else {
                collateralToken = await ERC20__factory.connect(expectedConfig.token, provider);
            }
            const actualToken = await hypToken.wrappedToken();
            if (!eqAddress(collateralToken.address, actualToken)) {
                const violation = {
                    type: 'CollateralTokenMismatch',
                    chain,
                    expected: collateralToken.address,
                    actual: actualToken,
                    tokenAddress: hypToken.address,
                };
                this.addViolation(violation);
            }
        }
    }
}
//# sourceMappingURL=checker.js.map
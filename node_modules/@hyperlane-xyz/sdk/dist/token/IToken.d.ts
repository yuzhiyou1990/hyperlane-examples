import { z } from 'zod';
import { Address, Numberish, ProtocolType } from '@hyperlane-xyz/utils';
import type { MultiProtocolProvider } from '../providers/MultiProtocolProvider.js';
import type { ChainName } from '../types.js';
import type { TokenAmount } from './TokenAmount.js';
import { type TokenConnection } from './TokenConnection.js';
import { TokenStandard } from './TokenStandard.js';
import type { IHypTokenAdapter, ITokenAdapter } from './adapters/ITokenAdapter.js';
export declare const TokenConfigSchema: z.ZodObject<{
    chainName: z.ZodString;
    standard: z.ZodNativeEnum<typeof TokenStandard>;
    decimals: z.ZodNumber;
    symbol: z.ZodString;
    name: z.ZodString;
    addressOrDenom: z.ZodUnion<[z.ZodString, z.ZodNull]>;
    collateralAddressOrDenom: z.ZodOptional<z.ZodString>;
    igpTokenAddressOrDenom: z.ZodOptional<z.ZodString>;
    logoURI: z.ZodOptional<z.ZodString>;
    connections: z.ZodOptional<z.ZodArray<z.ZodUnion<[z.ZodUnion<[z.ZodObject<{
        type: z.ZodOptional<z.ZodLiteral<import("./TokenConnection.js").TokenConnectionType.Hyperlane>>;
        token: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        token: string;
        type?: import("./TokenConnection.js").TokenConnectionType.Hyperlane | undefined;
    }, {
        token: string;
        type?: import("./TokenConnection.js").TokenConnectionType.Hyperlane | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<import("./TokenConnection.js").TokenConnectionType.Ibc>;
        token: z.ZodString;
        sourcePort: z.ZodString;
        sourceChannel: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        type: import("./TokenConnection.js").TokenConnectionType.Ibc;
        token: string;
        sourcePort: string;
        sourceChannel: string;
    }, {
        type: import("./TokenConnection.js").TokenConnectionType.Ibc;
        token: string;
        sourcePort: string;
        sourceChannel: string;
    }>]>, z.ZodObject<{
        type: z.ZodLiteral<import("./TokenConnection.js").TokenConnectionType.IbcHyperlane>;
        token: z.ZodString;
        sourcePort: z.ZodString;
        sourceChannel: z.ZodString;
        intermediateChainName: z.ZodString;
        intermediateIbcDenom: z.ZodString;
        intermediateRouterAddress: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        type: import("./TokenConnection.js").TokenConnectionType.IbcHyperlane;
        token: string;
        sourcePort: string;
        sourceChannel: string;
        intermediateRouterAddress: string;
        intermediateChainName: string;
        intermediateIbcDenom: string;
    }, {
        type: import("./TokenConnection.js").TokenConnectionType.IbcHyperlane;
        token: string;
        sourcePort: string;
        sourceChannel: string;
        intermediateRouterAddress: string;
        intermediateChainName: string;
        intermediateIbcDenom: string;
    }>]>, "many">>;
    coinGeckoId: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    symbol: string;
    name: string;
    decimals: number;
    standard: TokenStandard;
    chainName: string;
    addressOrDenom: string | null;
    collateralAddressOrDenom?: string | undefined;
    igpTokenAddressOrDenom?: string | undefined;
    logoURI?: string | undefined;
    connections?: ({
        token: string;
        type?: import("./TokenConnection.js").TokenConnectionType.Hyperlane | undefined;
    } | {
        type: import("./TokenConnection.js").TokenConnectionType.Ibc;
        token: string;
        sourcePort: string;
        sourceChannel: string;
    } | {
        type: import("./TokenConnection.js").TokenConnectionType.IbcHyperlane;
        token: string;
        sourcePort: string;
        sourceChannel: string;
        intermediateRouterAddress: string;
        intermediateChainName: string;
        intermediateIbcDenom: string;
    })[] | undefined;
    coinGeckoId?: string | undefined;
}, {
    symbol: string;
    name: string;
    decimals: number;
    standard: TokenStandard;
    chainName: string;
    addressOrDenom: string | null;
    collateralAddressOrDenom?: string | undefined;
    igpTokenAddressOrDenom?: string | undefined;
    logoURI?: string | undefined;
    connections?: ({
        token: string;
        type?: import("./TokenConnection.js").TokenConnectionType.Hyperlane | undefined;
    } | {
        type: import("./TokenConnection.js").TokenConnectionType.Ibc;
        token: string;
        sourcePort: string;
        sourceChannel: string;
    } | {
        type: import("./TokenConnection.js").TokenConnectionType.IbcHyperlane;
        token: string;
        sourcePort: string;
        sourceChannel: string;
        intermediateRouterAddress: string;
        intermediateChainName: string;
        intermediateIbcDenom: string;
    })[] | undefined;
    coinGeckoId?: string | undefined;
}>;
export type TokenArgs = Omit<z.infer<typeof TokenConfigSchema>, 'addressOrDenom' | 'connections'> & {
    addressOrDenom: Address | string;
    connections?: Array<TokenConnection>;
};
export interface IToken extends TokenArgs {
    protocol: ProtocolType;
    getAdapter(multiProvider: MultiProtocolProvider): ITokenAdapter<unknown>;
    getHypAdapter(multiProvider: MultiProtocolProvider<{
        mailbox?: Address;
    }>, destination?: ChainName): IHypTokenAdapter<unknown>;
    getBalance(multiProvider: MultiProtocolProvider, address: Address): Promise<TokenAmount>;
    amount(amount: Numberish): TokenAmount;
    isNft(): boolean;
    isNative(): boolean;
    isHypToken(): boolean;
    isIbcToken(): boolean;
    isMultiChainToken(): boolean;
    getConnections(): TokenConnection[];
    getConnectionForChain(chain: ChainName): TokenConnection | undefined;
    addConnection(connection: TokenConnection): IToken;
    removeConnection(token: IToken): IToken;
    equals(token?: IToken): boolean;
    isFungibleWith(token?: IToken): boolean;
}
//# sourceMappingURL=IToken.d.ts.map
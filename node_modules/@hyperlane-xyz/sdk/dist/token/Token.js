import { ERC20__factory } from '@hyperlane-xyz/core';
import { assert, eqAddress, } from '@hyperlane-xyz/utils';
import { Contract, utils } from "ethers";
import { encodeAbiParameters, pad } from 'viem';
import { TokenAmount } from './TokenAmount.js';
import { TokenConnectionType } from './TokenConnection.js';
import { PROTOCOL_TO_NATIVE_STANDARD, TOKEN_COLLATERALIZED_STANDARDS, TOKEN_HYP_STANDARDS, TOKEN_MULTI_CHAIN_STANDARDS, TOKEN_NFT_STANDARDS, TOKEN_STANDARD_TO_PROTOCOL, TokenStandard, XERC20_STANDARDS, } from './TokenStandard.js';
import { CwHypCollateralAdapter, CwHypNativeAdapter, CwHypSyntheticAdapter, CwNativeTokenAdapter, CwTokenAdapter, } from './adapters/CosmWasmTokenAdapter.js';
import { CosmIbcToWarpTokenAdapter, CosmIbcTokenAdapter, CosmNativeTokenAdapter, } from './adapters/CosmosTokenAdapter.js';
import { EvmHypCollateralAdapter, EvmHypCollateralFiatAdapter, EvmHypNativeAdapter, EvmHypSyntheticAdapter, EvmHypXERC20Adapter, EvmHypXERC20LockboxAdapter, EvmNativeTokenAdapter, EvmTokenAdapter, } from './adapters/EvmTokenAdapter.js';
import { SealevelHypCollateralAdapter, SealevelHypNativeAdapter, SealevelHypSyntheticAdapter, SealevelNativeTokenAdapter, SealevelTokenAdapter, } from './adapters/SealevelTokenAdapter.js';
const _abi = [ { inputs: [ { internalType: "address", name: "_mailbox", type: "address", }, { internalType: "address", name: "_permit2", type: "address", }, ], stateMutability: "nonpayable", type: "constructor", }, { inputs: [], name: "InvalidDomain", type: "error", }, { inputs: [], name: "InvalidGaslessOrderOrigin", type: "error", }, { inputs: [], name: "InvalidGaslessOrderSettler", type: "error", }, { inputs: [], name: "InvalidNativeAmount", type: "error", }, { inputs: [], name: "InvalidNonce", type: "error", }, { inputs: [], name: "InvalidOrderDomain", type: "error", }, { inputs: [], name: "InvalidOrderId", type: "error", }, { inputs: [], name: "InvalidOrderOrigin", type: "error", }, { inputs: [], name: "InvalidOrderStatus", type: "error", }, { inputs: [ { internalType: "bytes32", name: "orderType", type: "bytes32", }, ], name: "InvalidOrderType", type: "error", }, { inputs: [ { internalType: "uint32", name: "originDomain", type: "uint32", }, ], name: "InvalidOriginDomain", type: "error", }, { inputs: [], name: "InvalidSender", type: "error", }, { inputs: [], name: "OrderFillExpired", type: "error", }, { inputs: [], name: "OrderFillNotExpired", type: "error", }, { inputs: [], name: "OrderOpenExpired", type: "error", }, { anonymous: false, inputs: [ { indexed: false, internalType: "bytes32", name: "orderId", type: "bytes32", }, { indexed: false, internalType: "bytes", name: "originData", type: "bytes", }, { indexed: false, internalType: "bytes", name: "fillerData", type: "bytes", }, ], name: "Filled", type: "event", }, { anonymous: false, inputs: [ { indexed: false, internalType: "uint32", name: "domain", type: "uint32", }, { indexed: false, internalType: "uint256", name: "gas", type: "uint256", }, ], name: "GasSet", type: "event", }, { anonymous: false, inputs: [ { indexed: false, internalType: "address", name: "_hook", type: "address", }, ], name: "HookSet", type: "event", }, { anonymous: false, inputs: [ { indexed: false, internalType: "uint8", name: "version", type: "uint8", }, ], name: "Initialized", type: "event", }, { anonymous: false, inputs: [ { indexed: false, internalType: "address", name: "_ism", type: "address", }, ], name: "IsmSet", type: "event", }, { anonymous: false, inputs: [ { indexed: true, internalType: "address", name: "owner", type: "address", }, { indexed: false, internalType: "uint256", name: "nonce", type: "uint256", }, ], name: "NonceInvalidation", type: "event", }, { anonymous: false, inputs: [ { indexed: true, internalType: "bytes32", name: "orderId", type: "bytes32", }, { components: [ { internalType: "address", name: "user", type: "address", }, { internalType: "uint256", name: "originChainId", type: "uint256", }, { internalType: "uint32", name: "openDeadline", type: "uint32", }, { internalType: "uint32", name: "fillDeadline", type: "uint32", }, { internalType: "bytes32", name: "orderId", type: "bytes32", }, { components: [ { internalType: "bytes32", name: "token", type: "bytes32", }, { internalType: "uint256", name: "amount", type: "uint256", }, { internalType: "bytes32", name: "recipient", type: "bytes32", }, { internalType: "uint256", name: "chainId", type: "uint256", }, ], internalType: "struct Output[]", name: "maxSpent", type: "tuple[]", }, { components: [ { internalType: "bytes32", name: "token", type: "bytes32", }, { internalType: "uint256", name: "amount", type: "uint256", }, { internalType: "bytes32", name: "recipient", type: "bytes32", }, { internalType: "uint256", name: "chainId", type: "uint256", }, ], internalType: "struct Output[]", name: "minReceived", type: "tuple[]", }, { components: [ { internalType: "uint256", name: "destinationChainId", type: "uint256", }, { internalType: "bytes32", name: "destinationSettler", type: "bytes32", }, { internalType: "bytes", name: "originData", type: "bytes", }, ], internalType: "struct FillInstruction[]", name: "fillInstructions", type: "tuple[]", }, ], indexed: false, internalType: "struct ResolvedCrossChainOrder", name: "resolvedOrder", type: "tuple", }, ], name: "Open", type: "event", }, { anonymous: false, inputs: [ { indexed: true, internalType: "address", name: "previousOwner", type: "address", }, { indexed: true, internalType: "address", name: "newOwner", type: "address", }, ], name: "OwnershipTransferred", type: "event", }, { anonymous: false, inputs: [ { indexed: false, internalType: "bytes32[]", name: "orderIds", type: "bytes32[]", }, ], name: "Refund", type: "event", }, { anonymous: false, inputs: [ { indexed: false, internalType: "bytes32", name: "orderId", type: "bytes32", }, { indexed: false, internalType: "address", name: "receiver", type: "address", }, ], name: "Refunded", type: "event", }, { anonymous: false, inputs: [ { indexed: false, internalType: "bytes32[]", name: "orderIds", type: "bytes32[]", }, { indexed: false, internalType: "bytes[]", name: "ordersFillerData", type: "bytes[]", }, ], name: "Settle", type: "event", }, { anonymous: false, inputs: [ { indexed: false, internalType: "bytes32", name: "orderId", type: "bytes32", }, { indexed: false, internalType: "address", name: "receiver", type: "address", }, ], name: "Settled", type: "event", }, { inputs: [], name: "FILLED", outputs: [ { internalType: "bytes32", name: "", type: "bytes32", }, ], stateMutability: "view", type: "function", }, { inputs: [], name: "OPENED", outputs: [ { internalType: "bytes32", name: "", type: "bytes32", }, ], stateMutability: "view", type: "function", }, { inputs: [], name: "PACKAGE_VERSION", outputs: [ { internalType: "string", name: "", type: "string", }, ], stateMutability: "view", type: "function", }, { inputs: [], name: "PERMIT2", outputs: [ { internalType: "contract IPermit2", name: "", type: "address", }, ], stateMutability: "view", type: "function", }, { inputs: [], name: "REFUNDED", outputs: [ { internalType: "bytes32", name: "", type: "bytes32", }, ], stateMutability: "view", type: "function", }, { inputs: [], name: "RESOLVED_CROSS_CHAIN_ORDER_TYPEHASH", outputs: [ { internalType: "bytes32", name: "", type: "bytes32", }, ], stateMutability: "view", type: "function", }, { inputs: [], name: "SETTLED", outputs: [ { internalType: "bytes32", name: "", type: "bytes32", }, ], stateMutability: "view", type: "function", }, { inputs: [], name: "UNKNOWN", outputs: [ { internalType: "bytes32", name: "", type: "bytes32", }, ], stateMutability: "view", type: "function", }, { inputs: [ { internalType: "uint32", name: "", type: "uint32", }, ], name: "destinationGas", outputs: [ { internalType: "uint256", name: "", type: "uint256", }, ], stateMutability: "view", type: "function", }, { inputs: [], name: "domains", outputs: [ { internalType: "uint32[]", name: "", type: "uint32[]", }, ], stateMutability: "view", type: "function", }, { inputs: [ { internalType: "uint32", name: "_domain", type: "uint32", }, { internalType: "bytes32", name: "_router", type: "bytes32", }, ], name: "enrollRemoteRouter", outputs: [], stateMutability: "nonpayable", type: "function", }, { inputs: [ { internalType: "uint32[]", name: "_domains", type: "uint32[]", }, { internalType: "bytes32[]", name: "_addresses", type: "bytes32[]", }, ], name: "enrollRemoteRouters", outputs: [], stateMutability: "nonpayable", type: "function", }, { inputs: [ { internalType: "bytes32", name: "_orderId", type: "bytes32", }, { internalType: "bytes", name: "_originData", type: "bytes", }, { internalType: "bytes", name: "_fillerData", type: "bytes", }, ], name: "fill", outputs: [], stateMutability: "payable", type: "function", }, { inputs: [ { internalType: "bytes32", name: "orderId", type: "bytes32", }, ], name: "filledOrders", outputs: [ { internalType: "bytes", name: "originData", type: "bytes", }, { internalType: "bytes", name: "fillerData", type: "bytes", }, ], stateMutability: "view", type: "function", }, { inputs: [ { internalType: "uint32", name: "_origin", type: "uint32", }, { internalType: "bytes32", name: "_sender", type: "bytes32", }, { internalType: "bytes", name: "_message", type: "bytes", }, ], name: "handle", outputs: [], stateMutability: "payable", type: "function", }, { inputs: [], name: "hook", outputs: [ { internalType: "contract IPostDispatchHook", name: "", type: "address", }, ], stateMutability: "view", type: "function", }, { inputs: [ { internalType: "address", name: "_customHook", type: "address", }, { internalType: "address", name: "_interchainSecurityModule", type: "address", }, { internalType: "address", name: "_owner", type: "address", }, ], name: "initialize", outputs: [], stateMutability: "nonpayable", type: "function", }, { inputs: [], name: "interchainSecurityModule", outputs: [ { internalType: "contract IInterchainSecurityModule", name: "", type: "address", }, ], stateMutability: "view", type: "function", }, { inputs: [ { internalType: "uint256", name: "_nonce", type: "uint256", }, ], name: "invalidateNonces", outputs: [], stateMutability: "nonpayable", type: "function", }, { inputs: [ { internalType: "address", name: "_from", type: "address", }, { internalType: "uint256", name: "_nonce", type: "uint256", }, ], name: "isValidNonce", outputs: [ { internalType: "bool", name: "", type: "bool", }, ], stateMutability: "view", type: "function", }, { inputs: [], name: "localDomain", outputs: [ { internalType: "uint32", name: "", type: "uint32", }, ], stateMutability: "view", type: "function", }, { inputs: [], name: "mailbox", outputs: [ { internalType: "contract IMailbox", name: "", type: "address", }, ], stateMutability: "view", type: "function", }, { inputs: [ { components: [ { internalType: "uint32", name: "fillDeadline", type: "uint32", }, { internalType: "bytes32", name: "orderDataType", type: "bytes32", }, { internalType: "bytes", name: "orderData", type: "bytes", }, ], internalType: "struct OnchainCrossChainOrder", name: "_order", type: "tuple", }, ], name: "open", outputs: [], stateMutability: "payable", type: "function", }, { inputs: [ { components: [ { internalType: "address", name: "originSettler", type: "address", }, { internalType: "address", name: "user", type: "address", }, { internalType: "uint256", name: "nonce", type: "uint256", }, { internalType: "uint256", name: "originChainId", type: "uint256", }, { internalType: "uint32", name: "openDeadline", type: "uint32", }, { internalType: "uint32", name: "fillDeadline", type: "uint32", }, { internalType: "bytes32", name: "orderDataType", type: "bytes32", }, { internalType: "bytes", name: "orderData", type: "bytes", }, ], internalType: "struct GaslessCrossChainOrder", name: "_order", type: "tuple", }, { internalType: "bytes", name: "_signature", type: "bytes", }, { internalType: "bytes", name: "_originFillerData", type: "bytes", }, ], name: "openFor", outputs: [], stateMutability: "nonpayable", type: "function", }, { inputs: [ { internalType: "bytes32", name: "orderId", type: "bytes32", }, ], name: "openOrders", outputs: [ { internalType: "bytes", name: "orderData", type: "bytes", }, ], stateMutability: "view", type: "function", }, { inputs: [ { internalType: "bytes32", name: "orderId", type: "bytes32", }, ], name: "orderStatus", outputs: [ { internalType: "bytes32", name: "status", type: "bytes32", }, ], stateMutability: "view", type: "function", }, { inputs: [], name: "owner", outputs: [ { internalType: "address", name: "", type: "address", }, ], stateMutability: "view", type: "function", }, { inputs: [ { internalType: "uint32", name: "_destinationDomain", type: "uint32", }, ], name: "quoteGasPayment", outputs: [ { internalType: "uint256", name: "", type: "uint256", }, ], stateMutability: "view", type: "function", }, { inputs: [ { components: [ { internalType: "uint32", name: "fillDeadline", type: "uint32", }, { internalType: "bytes32", name: "orderDataType", type: "bytes32", }, { internalType: "bytes", name: "orderData", type: "bytes", }, ], internalType: "struct OnchainCrossChainOrder[]", name: "_orders", type: "tuple[]", }, ], name: "refund", outputs: [], stateMutability: "payable", type: "function", }, { inputs: [ { components: [ { internalType: "address", name: "originSettler", type: "address", }, { internalType: "address", name: "user", type: "address", }, { internalType: "uint256", name: "nonce", type: "uint256", }, { internalType: "uint256", name: "originChainId", type: "uint256", }, { internalType: "uint32", name: "openDeadline", type: "uint32", }, { internalType: "uint32", name: "fillDeadline", type: "uint32", }, { internalType: "bytes32", name: "orderDataType", type: "bytes32", }, { internalType: "bytes", name: "orderData", type: "bytes", }, ], internalType: "struct GaslessCrossChainOrder[]", name: "_orders", type: "tuple[]", }, ], name: "refund", outputs: [], stateMutability: "payable", type: "function", }, { inputs: [], name: "renounceOwnership", outputs: [], stateMutability: "nonpayable", type: "function", }, { inputs: [ { components: [ { internalType: "uint32", name: "fillDeadline", type: "uint32", }, { internalType: "bytes32", name: "orderDataType", type: "bytes32", }, { internalType: "bytes", name: "orderData", type: "bytes", }, ], internalType: "struct OnchainCrossChainOrder", name: "_order", type: "tuple", }, ], name: "resolve", outputs: [ { components: [ { internalType: "address", name: "user", type: "address", }, { internalType: "uint256", name: "originChainId", type: "uint256", }, { internalType: "uint32", name: "openDeadline", type: "uint32", }, { internalType: "uint32", name: "fillDeadline", type: "uint32", }, { internalType: "bytes32", name: "orderId", type: "bytes32", }, { components: [ { internalType: "bytes32", name: "token", type: "bytes32", }, { internalType: "uint256", name: "amount", type: "uint256", }, { internalType: "bytes32", name: "recipient", type: "bytes32", }, { internalType: "uint256", name: "chainId", type: "uint256", }, ], internalType: "struct Output[]", name: "maxSpent", type: "tuple[]", }, { components: [ { internalType: "bytes32", name: "token", type: "bytes32", }, { internalType: "uint256", name: "amount", type: "uint256", }, { internalType: "bytes32", name: "recipient", type: "bytes32", }, { internalType: "uint256", name: "chainId", type: "uint256", }, ], internalType: "struct Output[]", name: "minReceived", type: "tuple[]", }, { components: [ { internalType: "uint256", name: "destinationChainId", type: "uint256", }, { internalType: "bytes32", name: "destinationSettler", type: "bytes32", }, { internalType: "bytes", name: "originData", type: "bytes", }, ], internalType: "struct FillInstruction[]", name: "fillInstructions", type: "tuple[]", }, ], internalType: "struct ResolvedCrossChainOrder", name: "_resolvedOrder", type: "tuple", }, ], stateMutability: "view", type: "function", }, { inputs: [ { components: [ { internalType: "address", name: "originSettler", type: "address", }, { internalType: "address", name: "user", type: "address", }, { internalType: "uint256", name: "nonce", type: "uint256", }, { internalType: "uint256", name: "originChainId", type: "uint256", }, { internalType: "uint32", name: "openDeadline", type: "uint32", }, { internalType: "uint32", name: "fillDeadline", type: "uint32", }, { internalType: "bytes32", name: "orderDataType", type: "bytes32", }, { internalType: "bytes", name: "orderData", type: "bytes", }, ], internalType: "struct GaslessCrossChainOrder", name: "_order", type: "tuple", }, { internalType: "bytes", name: "_originFillerData", type: "bytes", }, ], name: "resolveFor", outputs: [ { components: [ { internalType: "address", name: "user", type: "address", }, { internalType: "uint256", name: "originChainId", type: "uint256", }, { internalType: "uint32", name: "openDeadline", type: "uint32", }, { internalType: "uint32", name: "fillDeadline", type: "uint32", }, { internalType: "bytes32", name: "orderId", type: "bytes32", }, { components: [ { internalType: "bytes32", name: "token", type: "bytes32", }, { internalType: "uint256", name: "amount", type: "uint256", }, { internalType: "bytes32", name: "recipient", type: "bytes32", }, { internalType: "uint256", name: "chainId", type: "uint256", }, ], internalType: "struct Output[]", name: "maxSpent", type: "tuple[]", }, { components: [ { internalType: "bytes32", name: "token", type: "bytes32", }, { internalType: "uint256", name: "amount", type: "uint256", }, { internalType: "bytes32", name: "recipient", type: "bytes32", }, { internalType: "uint256", name: "chainId", type: "uint256", }, ], internalType: "struct Output[]", name: "minReceived", type: "tuple[]", }, { components: [ { internalType: "uint256", name: "destinationChainId", type: "uint256", }, { internalType: "bytes32", name: "destinationSettler", type: "bytes32", }, { internalType: "bytes", name: "originData", type: "bytes", }, ], internalType: "struct FillInstruction[]", name: "fillInstructions", type: "tuple[]", }, ], internalType: "struct ResolvedCrossChainOrder", name: "_resolvedOrder", type: "tuple", }, ], stateMutability: "view", type: "function", }, { inputs: [ { internalType: "uint32", name: "_domain", type: "uint32", }, ], name: "routers", outputs: [ { internalType: "bytes32", name: "", type: "bytes32", }, ], stateMutability: "view", type: "function", }, { inputs: [ { internalType: "uint32", name: "domain", type: "uint32", }, { internalType: "uint256", name: "gas", type: "uint256", }, ], name: "setDestinationGas", outputs: [], stateMutability: "nonpayable", type: "function", }, { inputs: [ { components: [ { internalType: "uint32", name: "domain", type: "uint32", }, { internalType: "uint256", name: "gas", type: "uint256", }, ], internalType: "struct GasRouter.GasRouterConfig[]", name: "gasConfigs", type: "tuple[]", }, ], name: "setDestinationGas", outputs: [], stateMutability: "nonpayable", type: "function", }, { inputs: [ { internalType: "address", name: "_hook", type: "address", }, ], name: "setHook", outputs: [], stateMutability: "nonpayable", type: "function", }, { inputs: [ { internalType: "address", name: "_module", type: "address", }, ], name: "setInterchainSecurityModule", outputs: [], stateMutability: "nonpayable", type: "function", }, { inputs: [ { internalType: "bytes32[]", name: "_orderIds", type: "bytes32[]", }, ], name: "settle", outputs: [], stateMutability: "payable", type: "function", }, { inputs: [ { internalType: "address", name: "newOwner", type: "address", }, ], name: "transferOwnership", outputs: [], stateMutability: "nonpayable", type: "function", }, { inputs: [ { internalType: "uint32", name: "_domain", type: "uint32", }, ], name: "unenrollRemoteRouter", outputs: [], stateMutability: "nonpayable", type: "function", }, { inputs: [ { internalType: "uint32[]", name: "_domains", type: "uint32[]", }, ], name: "unenrollRemoteRouters", outputs: [], stateMutability: "nonpayable", type: "function", }, { inputs: [ { internalType: "address", name: "", type: "address", }, { internalType: "uint256", name: "", type: "uint256", }, ], name: "usedNonces", outputs: [ { internalType: "bool", name: "", type: "bool", }, ], stateMutability: "view", type: "function", }, { inputs: [ { components: [ { internalType: "address", name: "user", type: "address", }, { internalType: "uint256", name: "originChainId", type: "uint256", }, { internalType: "uint32", name: "openDeadline", type: "uint32", }, { internalType: "uint32", name: "fillDeadline", type: "uint32", }, { internalType: "bytes32", name: "orderId", type: "bytes32", }, { components: [ { internalType: "bytes32", name: "token", type: "bytes32", }, { internalType: "uint256", name: "amount", type: "uint256", }, { internalType: "bytes32", name: "recipient", type: "bytes32", }, { internalType: "uint256", name: "chainId", type: "uint256", }, ], internalType: "struct Output[]", name: "maxSpent", type: "tuple[]", }, { components: [ { internalType: "bytes32", name: "token", type: "bytes32", }, { internalType: "uint256", name: "amount", type: "uint256", }, { internalType: "bytes32", name: "recipient", type: "bytes32", }, { internalType: "uint256", name: "chainId", type: "uint256", }, ], internalType: "struct Output[]", name: "minReceived", type: "tuple[]", }, { components: [ { internalType: "uint256", name: "destinationChainId", type: "uint256", }, { internalType: "bytes32", name: "destinationSettler", type: "bytes32", }, { internalType: "bytes", name: "originData", type: "bytes", }, ], internalType: "struct FillInstruction[]", name: "fillInstructions", type: "tuple[]", }, ], internalType: "struct ResolvedCrossChainOrder", name: "_resolvedOrder", type: "tuple", }, ], name: "witnessHash", outputs: [ { internalType: "bytes32", name: "", type: "bytes32", }, ], stateMutability: "pure", type: "function", }, { inputs: [], name: "witnessTypeString", outputs: [ { internalType: "string", name: "", type: "string", }, ], stateMutability: "view", type: "function", }, ];

export class Hyperlane7683__factory {
  static abi = _abi;
  static createInterface() {
    return new utils.Interface(_abi);
  }
  static connect(
    address,
    signerOrProvider
  ) {
    return new Contract(address, _abi, signerOrProvider);
  }
}
export class EvmIntentTokenAdapter extends EvmTokenAdapter {
  contract;
  intent;
  constructor(
    chainName,
    multiProvider,
    addresses,
    contractFactory = ERC20__factory,
    intentFactory = Hyperlane7683__factory,
  ) {
    super(chainName, multiProvider, addresses);
    this.contract = contractFactory.connect(
      addresses.token,
      this.getProvider(),
    );
    this.intent = intentFactory.connect(addresses.router, this.getProvider());
  }
  async populateOpenOrderTx({
    sender,
    recipient,
    outputToken,
    destinationSettler,
    amountIn,
    amountOut,
    destinationDomain,
    fillDeadline,
  }) {
    const orderDataType =
      '0x08d75650babf4de09c9273d48ef647876057ed91d4323f8a2e3ebc2cd8a63b5e';
    const senderNonce = Date.now();

    return this.intent.populateTransaction.open({
      fillDeadline,
      orderDataType,
      orderData: encodeAbiParameters(
        [
          {
            components: [
              { name: 'sender', type: 'bytes32' },
              { name: 'recipient', type: 'bytes32' },
              { name: 'inputToken', type: 'bytes32' },
              { name: 'outputToken', type: 'bytes32' },
              { name: 'amountIn', type: 'uint256' },
              { name: 'amountOut', type: 'uint256' },
              { name: 'senderNonce', type: 'uint256' },
              { name: 'originDomain', type: 'uint32' },
              { name: 'destinationDomain', type: 'uint32' },
              { name: 'destinationSettler', type: 'bytes32' },
              { name: 'fillDeadline', type: 'uint32' },
              { name: 'data', type: 'bytes' },
            ],
            name: 'orderData',
            type: 'tuple',
          },
        ],
        [
          {
            sender: pad(sender),
            recipient: pad(recipient),
            inputToken: pad(this.addresses.token),
            outputToken: pad(outputToken),
            amountIn: BigInt(amountIn),
            amountOut: BigInt(amountOut),
            senderNonce: BigInt(senderNonce.toString()),
            originDomain: this.multiProvider.getChainId(this.chainName),
            destinationDomain: parseInt(destinationDomain),
            destinationSettler: pad(destinationSettler),
            fillDeadline: parseInt(fillDeadline),
            data: '0x',
          },
        ],
      ),
    });
  }
}
export class EvmIntentNativeTokenAdapter extends EvmNativeTokenAdapter {
  intent;

  constructor(
    chainName,
    multiProvider,
    addresses,
    intentFactory = Hyperlane7683__factory,
  ) {
    super(chainName, multiProvider, addresses);
    this.intent = intentFactory.connect(addresses.router, this.getProvider());
  }


  async populateOpenOrderTx({
    sender,
    recipient,
    outputToken,
    amountIn,
    amountOut,
    destinationDomain,
    fillDeadline,
  }) {
    const orderDataType =
      '0x08d75650babf4de09c9273d48ef647876057ed91d4323f8a2e3ebc2cd8a63b5e';
    const senderNonce = Date.now();

    return this.intent.populateTransaction.open({
      fillDeadline,
      orderDataType,
      orderData: encodeAbiParameters(
        [
          {
            components: [
              { name: 'sender', type: 'bytes32' },
              { name: 'recipient', type: 'bytes32' },
              { name: 'inputToken', type: 'bytes32' },
              { name: 'outputToken', type: 'bytes32' },
              { name: 'amountIn', type: 'uint256' },
              { name: 'amountOut', type: 'uint256' },
              { name: 'senderNonce', type: 'uint256' },
              { name: 'originDomain', type: 'uint32' },
              { name: 'destinationDomain', type: 'uint32' },
              { name: 'destinationSettler', type: 'bytes32'},
              { name: 'fillDeadline', type: 'uint32' },
              { name: 'data', type: 'bytes' },
            ],
            name: 'orderData',
            type: 'tuple',
          },
        ],
        [
          {
            sender: pad(sender),
            recipient: pad(recipient),
            inputToken: pad(this.addresses.token),
            outputToken: pad(outputToken),
            amountIn: BigInt(amountIn),
            amountOut: BigInt(amountOut),
            senderNonce: BigInt(senderNonce.toString()),
            originDomain: this.multiProvider.getChainId(this.chainName),
            destinationDomain: parseInt(destinationDomain),
            destinationSettler: pad(this.addresses.router),
            fillDeadline: parseInt(fillDeadline),
            data: '0x',
          },
        ],
      ),
    }, { value: amountIn });
  }
}
export class Token {
    protocol;
    constructor(args) {
        Object.assign(this, args);
        this.protocol = TOKEN_STANDARD_TO_PROTOCOL[this.standard];
    }
    static FromChainMetadataNativeToken(chainMetadata) {
        const { protocol, name: chainName, nativeToken, logoURI } = chainMetadata;
        assert(nativeToken, `ChainMetadata for ${chainMetadata.name} missing nativeToken`);
        return new Token({
            chainName,
            standard: PROTOCOL_TO_NATIVE_STANDARD[protocol],
            addressOrDenom: nativeToken.denom ?? '',
            decimals: nativeToken.decimals,
            symbol: nativeToken.symbol,
            name: nativeToken.name,
            logoURI,
        });
    }
    /**
     * Returns a TokenAdapter for the token and multiProvider
     * @throws If multiProvider does not contain this token's chain.
     * @throws If token is an NFT (TODO NFT Adapter support)
     */
    getAdapter(multiProvider) {
        const { standard, chainName, addressOrDenom, collateralAddressOrDenom } = this;
        assert(!this.isNft(), 'NFT adapters not yet supported');
        assert(multiProvider.tryGetChainMetadata(chainName), `Token chain ${chainName} not found in multiProvider`);
        if (standard === 'Intent' && collateralAddressOrDenom) {
            return new EvmIntentTokenAdapter(chainName, multiProvider, {
                token: addressOrDenom,
                router: collateralAddressOrDenom,
            })
        }
        if (standard === TokenStandard.IntentNative && collateralAddressOrDenom) {
            return new EvmIntentNativeTokenAdapter(chainName, multiProvider, {
                token: addressOrDenom,
                router: collateralAddressOrDenom,
            })
        }
        if (standard === TokenStandard.ERC20) {
            return new EvmTokenAdapter(chainName, multiProvider, {
                token: addressOrDenom,
            });
        }
        else if (standard === TokenStandard.EvmNative) {
            return new EvmNativeTokenAdapter(chainName, multiProvider, {});
        }
        else if (standard === TokenStandard.SealevelSpl) {
            return new SealevelTokenAdapter(chainName, multiProvider, { token: addressOrDenom }, false);
        }
        else if (standard === TokenStandard.SealevelSpl2022) {
            return new SealevelTokenAdapter(chainName, multiProvider, { token: addressOrDenom }, true);
        }
        else if (standard === TokenStandard.SealevelNative) {
            return new SealevelNativeTokenAdapter(chainName, multiProvider, {});
        }
        else if (standard === TokenStandard.CosmosIcs20) {
            throw new Error('Cosmos ICS20 token adapter not yet supported');
        }
        else if (standard === TokenStandard.CosmosNative) {
            return new CosmNativeTokenAdapter(chainName, multiProvider, {}, { ibcDenom: addressOrDenom });
        }
        else if (standard === TokenStandard.CW20) {
            return new CwTokenAdapter(chainName, multiProvider, {
                token: addressOrDenom,
            });
        }
        else if (standard === TokenStandard.CWNative) {
            return new CwNativeTokenAdapter(chainName, multiProvider, {}, addressOrDenom);
        }
        else if (this.isHypToken()) {
            return this.getHypAdapter(multiProvider);
        }
        else if (this.isIbcToken()) {
            // Passing in a stub connection here because it's not required
            // for an IBC adapter to fulfill the ITokenAdapter interface
            return this.getIbcAdapter(multiProvider, {
                token: this,
                sourcePort: 'transfer',
                sourceChannel: 'channel-0',
                type: TokenConnectionType.Ibc,
            });
        }
        else {
            throw new Error(`No adapter found for token standard: ${standard}`);
        }
    }
    /**
     * Returns a HypTokenAdapter for the token and multiProvider
     * @throws If not applicable to this token's standard.
     * @throws If multiProvider does not contain this token's chain.
     * @throws If token is an NFT (TODO NFT Adapter support)
     */
    getHypAdapter(multiProvider, destination) {
        const { standard, chainName, addressOrDenom, collateralAddressOrDenom } = this;
        const chainMetadata = multiProvider.tryGetChainMetadata(chainName);
        const mailbox = chainMetadata?.mailbox;
        assert(this.isMultiChainToken(), `Token standard ${standard} not applicable to hyp adapter`);
        assert(!this.isNft(), 'NFT adapters not yet supported');
        assert(chainMetadata, `Token chain ${chainName} not found in multiProvider`);
        if (standard === TokenStandard.EvmHypNative) {
            return new EvmHypNativeAdapter(chainName, multiProvider, {
                token: addressOrDenom,
            });
        }
        else if (standard === TokenStandard.EvmHypCollateral ||
            standard === TokenStandard.EvmHypOwnerCollateral ||
            standard === TokenStandard.EvmHypRebaseCollateral) {
            return new EvmHypCollateralAdapter(chainName, multiProvider, {
                token: addressOrDenom,
            });
        }
        else if (standard === TokenStandard.EvmHypCollateralFiat) {
            return new EvmHypCollateralFiatAdapter(chainName, multiProvider, {
                token: addressOrDenom,
            });
        }
        else if (standard === TokenStandard.EvmHypSynthetic ||
            standard === TokenStandard.EvmHypSyntheticRebase) {
            return new EvmHypSyntheticAdapter(chainName, multiProvider, {
                token: addressOrDenom,
            });
        }
        else if (standard === TokenStandard.EvmHypXERC20) {
            return new EvmHypXERC20Adapter(chainName, multiProvider, {
                token: addressOrDenom,
            });
        }
        else if (standard === TokenStandard.EvmHypXERC20Lockbox) {
            return new EvmHypXERC20LockboxAdapter(chainName, multiProvider, {
                token: addressOrDenom,
            });
        }
        else if (standard === TokenStandard.SealevelHypNative) {
            assert(mailbox, `Mailbox required for Sealevel hyp tokens`);
            return new SealevelHypNativeAdapter(chainName, multiProvider, {
                warpRouter: addressOrDenom,
                mailbox,
            }, false);
        }
        else if (standard === TokenStandard.SealevelHypCollateral) {
            assert(mailbox, `Mailbox required for Sealevel hyp tokens`);
            assert(collateralAddressOrDenom, `collateralAddressOrDenom required for Sealevel hyp collateral tokens`);
            return new SealevelHypCollateralAdapter(chainName, multiProvider, {
                warpRouter: addressOrDenom,
                token: collateralAddressOrDenom,
                mailbox,
            }, false);
        }
        else if (standard === TokenStandard.SealevelHypSynthetic) {
            assert(mailbox, `Mailbox required for Sealevel hyp tokens`);
            assert(collateralAddressOrDenom, `collateralAddressOrDenom required for Sealevel hyp synthetic tokens`);
            return new SealevelHypSyntheticAdapter(chainName, multiProvider, {
                warpRouter: addressOrDenom,
                token: collateralAddressOrDenom,
                mailbox,
            }, false);
        }
        else if (standard === TokenStandard.CwHypNative) {
            return new CwHypNativeAdapter(chainName, multiProvider, {
                warpRouter: addressOrDenom,
            });
        }
        else if (standard === TokenStandard.CwHypCollateral) {
            assert(collateralAddressOrDenom, 'collateralAddressOrDenom required for CwHypCollateral');
            return new CwHypCollateralAdapter(chainName, multiProvider, {
                warpRouter: addressOrDenom,
                token: collateralAddressOrDenom,
            });
        }
        else if (standard === TokenStandard.CwHypSynthetic) {
            assert(collateralAddressOrDenom, 'collateralAddressOrDenom required for CwHypSyntheticAdapter');
            return new CwHypSyntheticAdapter(chainName, multiProvider, {
                warpRouter: addressOrDenom,
                token: collateralAddressOrDenom,
            });
        }
        else if (standard === TokenStandard.CosmosIbc) {
            assert(destination, 'destination required for IBC token adapters');
            const connection = this.getConnectionForChain(destination);
            assert(connection, `No connection found for chain ${destination}`);
            return this.getIbcAdapter(multiProvider, connection);
        }
        else {
            throw new Error(`No hyp adapter found for token standard: ${standard}`);
        }
    }
    getIbcAdapter(multiProvider, connection) {
        if (connection.type === TokenConnectionType.Ibc) {
            const { sourcePort, sourceChannel } = connection;
            return new CosmIbcTokenAdapter(this.chainName, multiProvider, {}, { ibcDenom: this.addressOrDenom, sourcePort, sourceChannel });
        }
        else if (connection.type === TokenConnectionType.IbcHyperlane) {
            const { sourcePort, sourceChannel, intermediateChainName, intermediateIbcDenom, intermediateRouterAddress, } = connection;
            const destinationRouterAddress = connection.token.addressOrDenom;
            return new CosmIbcToWarpTokenAdapter(this.chainName, multiProvider, {
                intermediateRouterAddress,
                destinationRouterAddress,
            }, {
                ibcDenom: this.addressOrDenom,
                sourcePort,
                sourceChannel,
                intermediateIbcDenom,
                intermediateChainName,
            });
        }
        else {
            throw new Error(`Unsupported IBC connection type: ${connection.type}`);
        }
    }
    /**
     * Convenience method to create an adapter and return an account balance
     */
    async getBalance(multiProvider, address) {
        const adapter = this.getAdapter(multiProvider);
        const balance = await adapter.getBalance(address);
        return new TokenAmount(balance, this);
    }
    amount(amount) {
        return new TokenAmount(amount, this);
    }
    isNft() {
        return TOKEN_NFT_STANDARDS.includes(this.standard);
    }
    isNative() {
        return Object.values(PROTOCOL_TO_NATIVE_STANDARD).includes(this.standard);
    }
    isCollateralized() {
        return TOKEN_COLLATERALIZED_STANDARDS.includes(this.standard);
    }
    isHypToken() {
        return TOKEN_HYP_STANDARDS.includes(this.standard);
    }
    isXerc20() {
        return XERC20_STANDARDS.includes(this.standard);
    }
    isIbcToken() {
        return this.standard === TokenStandard.CosmosIbc;
    }
    isMultiChainToken() {
        return TOKEN_MULTI_CHAIN_STANDARDS.includes(this.standard);
    }
    getConnections() {
        return this.connections || [];
    }
    getConnectionForChain(chain) {
        // A token cannot have > 1 connected token for the same chain
        return this.getConnections().filter((t) => t.token.chainName === chain)[0];
    }
    addConnection(connection) {
        this.connections = [...(this.connections || []), connection];
        return this;
    }
    removeConnection(token) {
        const index = this.connections?.findIndex((t) => t.token.equals(token));
        if (index && index >= 0)
            this.connections?.splice(index, 1);
        return this;
    }
    /**
     * Returns true if tokens refer to the same asset
     */
    equals(token) {
        if (!token)
            return false;
        return (this.protocol === token.protocol &&
            this.chainName === token.chainName &&
            this.standard === token.standard &&
            this.decimals === token.decimals &&
            this.addressOrDenom.toLowerCase() ===
                token.addressOrDenom.toLowerCase() &&
            this.collateralAddressOrDenom?.toLowerCase() ===
                token.collateralAddressOrDenom?.toLowerCase());
    }
    /**
     * Two tokens may not be equal but may still represent the same underlying asset
     * The cases for this include:
     *   1) A HypCollateral contract token and its wrapped token (eg. EvmHypCollateral and ERC20)
     *   2) A HypNative contract and its native currency (eg. EvmHypNative and Ether)
     *   3) An IBC token and its native equivalent
     * This is useful during fee estimation to determine if a TokenAmount for the transfer and the fee
     * are actually fungible (represent the same asset).
     * @returns true if the tokens represent the same underlying asset
     */
    isFungibleWith(token) {
        if (!token || token.chainName !== this.chainName)
            return false;
        if (this.equals(token))
            return true;
        if (this.isCollateralized()) {
            if (this.collateralAddressOrDenom &&
                eqAddress(this.collateralAddressOrDenom, token.addressOrDenom)) {
                return true;
            }
            if (!this.collateralAddressOrDenom && token.isNative()) {
                return true;
            }
        }
        if (this.standard === TokenStandard.CosmosIbc &&
            token.standard === TokenStandard.CosmosNative &&
            this.addressOrDenom.toLowerCase() === token.addressOrDenom.toLowerCase()) {
            return true;
        }
        return false;
    }
}
//# sourceMappingURL=Token.js.map
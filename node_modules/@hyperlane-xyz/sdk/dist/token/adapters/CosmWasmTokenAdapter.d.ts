/// <reference types="node" resolution-mode="require"/>
import { ExecuteInstruction } from '@cosmjs/cosmwasm-stargate';
import { Coin } from '@cosmjs/stargate';
import { Address, Domain } from '@hyperlane-xyz/utils';
import { BaseCosmWasmAdapter } from '../../app/MultiProtocolApp.js';
import { BalanceResponse, ExecuteMsg as Cw20Execute, QueryMsg as Cw20Query, TokenInfoResponse } from '../../cw-types/Cw20Base.types.js';
import { QuoteDispatchResponse } from '../../cw-types/Mailbox.types.js';
import { DomainsResponse, InterchainSecurityModuleResponse, OwnerResponse, RouteResponseForHexBinary, RoutesResponseForHexBinary, TokenType, TokenTypeResponse, ExecuteMsg as WarpCw20Execute, QueryMsg as WarpCw20Query } from '../../cw-types/WarpCw20.types.js';
import { MultiProtocolProvider } from '../../providers/MultiProtocolProvider.js';
import { ChainName } from '../../types.js';
import { TokenMetadata } from '../types.js';
import { IHypTokenAdapter, ITokenAdapter, InterchainGasQuote, TransferParams, TransferRemoteParams } from './ITokenAdapter.js';
export declare class CwNativeTokenAdapter extends BaseCosmWasmAdapter implements ITokenAdapter<ExecuteInstruction> {
    readonly chainName: string;
    readonly multiProvider: MultiProtocolProvider;
    readonly addresses: Record<string, Address>;
    readonly denom: string;
    constructor(chainName: string, multiProvider: MultiProtocolProvider, addresses: Record<string, Address>, denom: string);
    getBalance(address: Address): Promise<bigint>;
    getMetadata(): Promise<CW20Metadata>;
    isApproveRequired(): Promise<boolean>;
    populateApproveTx(_params: TransferParams): Promise<ExecuteInstruction>;
    populateTransferTx({ recipient, weiAmountOrId, }: TransferParams): Promise<ExecuteInstruction>;
    getTotalSupply(): Promise<bigint | undefined>;
}
export type CW20Metadata = TokenMetadata;
type CW20Response = TokenInfoResponse | BalanceResponse;
export declare class CwTokenAdapter extends BaseCosmWasmAdapter implements ITokenAdapter<ExecuteInstruction> {
    readonly chainName: string;
    readonly multiProvider: MultiProtocolProvider;
    readonly addresses: {
        token: Address;
    };
    constructor(chainName: string, multiProvider: MultiProtocolProvider, addresses: {
        token: Address;
    });
    queryToken<R extends CW20Response>(msg: Cw20Query): Promise<R>;
    prepareToken(msg: Cw20Execute, funds?: Coin[]): ExecuteInstruction;
    getBalance(address: Address): Promise<bigint>;
    getMetadata(): Promise<CW20Metadata>;
    isApproveRequired(): Promise<boolean>;
    populateApproveTx({ weiAmountOrId, recipient, }: TransferParams): Promise<ExecuteInstruction>;
    populateTransferTx({ weiAmountOrId, recipient, }: TransferParams): Promise<ExecuteInstruction>;
    getTotalSupply(): Promise<bigint | undefined>;
}
type TokenRouterResponse = TokenTypeResponse | InterchainSecurityModuleResponse | DomainsResponse | OwnerResponse | RouteResponseForHexBinary | RoutesResponseForHexBinary | QuoteDispatchResponse;
export declare class CwHypSyntheticAdapter extends CwTokenAdapter implements IHypTokenAdapter<ExecuteInstruction> {
    readonly chainName: ChainName;
    readonly multiProvider: MultiProtocolProvider<any>;
    readonly addresses: {
        token: Address;
        warpRouter: Address;
    };
    constructor(chainName: ChainName, multiProvider: MultiProtocolProvider<any>, addresses: {
        token: Address;
        warpRouter: Address;
    });
    queryRouter<R extends TokenRouterResponse>(msg: WarpCw20Query): Promise<R>;
    prepareRouter(msg: WarpCw20Execute, funds?: Coin[]): ExecuteInstruction;
    getTokenType(): Promise<TokenType>;
    getInterchainSecurityModule(): Promise<Address>;
    getOwner(): Promise<Address>;
    getDomains(): Promise<Domain[]>;
    getRouterAddress(domain: Domain): Promise<Buffer>;
    getAllRouters(): Promise<Array<{
        domain: Domain;
        address: Buffer;
    }>>;
    getBridgedSupply(): Promise<bigint | undefined>;
    quoteTransferRemoteGas(_destination: Domain): Promise<InterchainGasQuote>;
    populateTransferRemoteTx({ destination, recipient, weiAmountOrId, interchainGas, }: TransferRemoteParams): Promise<ExecuteInstruction>;
}
export declare class CwHypNativeAdapter extends CwNativeTokenAdapter implements IHypTokenAdapter<ExecuteInstruction> {
    readonly chainName: ChainName;
    readonly multiProvider: MultiProtocolProvider<any>;
    readonly addresses: {
        warpRouter: Address;
    };
    private readonly cw20adapter;
    constructor(chainName: ChainName, multiProvider: MultiProtocolProvider<any>, addresses: {
        warpRouter: Address;
    });
    getBalance(address: string): Promise<bigint>;
    getInterchainSecurityModule(): Promise<Address>;
    getOwner(): Promise<Address>;
    getDomains(): Promise<Domain[]>;
    getRouterAddress(domain: Domain): Promise<Buffer>;
    getAllRouters(): Promise<Array<{
        domain: Domain;
        address: Buffer;
    }>>;
    getBridgedSupply(): Promise<bigint>;
    quoteTransferRemoteGas(destination: Domain): Promise<InterchainGasQuote>;
    getDenom(): Promise<string>;
    populateTransferRemoteTx({ destination, recipient, weiAmountOrId, interchainGas, }: TransferRemoteParams): Promise<ExecuteInstruction>;
}
export declare class CwHypCollateralAdapter extends CwHypNativeAdapter implements IHypTokenAdapter<ExecuteInstruction> {
    readonly chainName: ChainName;
    readonly multiProvider: MultiProtocolProvider<any>;
    readonly addresses: {
        warpRouter: Address;
        token: Address;
    };
    constructor(chainName: ChainName, multiProvider: MultiProtocolProvider<any>, addresses: {
        warpRouter: Address;
        token: Address;
    });
}
export {};
//# sourceMappingURL=CosmWasmTokenAdapter.d.ts.map
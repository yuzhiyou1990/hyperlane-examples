import { MsgTransferEncodeObject } from '@cosmjs/stargate';
import { Address, Numberish, ProtocolType } from '@hyperlane-xyz/utils';
import { ChainMetadata } from '../metadata/chainMetadataTypes.js';
import { MultiProtocolProvider } from '../providers/MultiProtocolProvider.js';
import { ChainName } from '../types.js';
import type { IToken, TokenArgs } from './IToken.js';
import { TokenAmount } from './TokenAmount.js';
import { TokenConnection } from './TokenConnection.js';
import type { IHypTokenAdapter, ITokenAdapter } from './adapters/ITokenAdapter.js';
export interface Token extends TokenArgs {
}
export declare class Token implements IToken {
    readonly protocol: ProtocolType;
    constructor(args: TokenArgs);
    static FromChainMetadataNativeToken(chainMetadata: ChainMetadata): Token;
    /**
     * Returns a TokenAdapter for the token and multiProvider
     * @throws If multiProvider does not contain this token's chain.
     * @throws If token is an NFT (TODO NFT Adapter support)
     */
    getAdapter(multiProvider: MultiProtocolProvider): ITokenAdapter<unknown>;
    /**
     * Returns a HypTokenAdapter for the token and multiProvider
     * @throws If not applicable to this token's standard.
     * @throws If multiProvider does not contain this token's chain.
     * @throws If token is an NFT (TODO NFT Adapter support)
     */
    getHypAdapter(multiProvider: MultiProtocolProvider<{
        mailbox?: Address;
    }>, destination?: ChainName): IHypTokenAdapter<unknown>;
    protected getIbcAdapter(multiProvider: MultiProtocolProvider, connection: TokenConnection): IHypTokenAdapter<MsgTransferEncodeObject>;
    /**
     * Convenience method to create an adapter and return an account balance
     */
    getBalance(multiProvider: MultiProtocolProvider, address: Address): Promise<TokenAmount>;
    amount(amount: Numberish): TokenAmount;
    isNft(): boolean;
    isNative(): boolean;
    isCollateralized(): boolean;
    isHypToken(): boolean;
    isXerc20(): boolean;
    isIbcToken(): boolean;
    isMultiChainToken(): boolean;
    getConnections(): TokenConnection[];
    getConnectionForChain(chain: ChainName): TokenConnection | undefined;
    addConnection(connection: TokenConnection): Token;
    removeConnection(token: IToken): Token;
    /**
     * Returns true if tokens refer to the same asset
     */
    equals(token?: IToken): boolean;
    /**
     * Two tokens may not be equal but may still represent the same underlying asset
     * The cases for this include:
     *   1) A HypCollateral contract token and its wrapped token (eg. EvmHypCollateral and ERC20)
     *   2) A HypNative contract and its native currency (eg. EvmHypNative and Ether)
     *   3) An IBC token and its native equivalent
     * This is useful during fee estimation to determine if a TokenAmount for the transfer and the fee
     * are actually fungible (represent the same asset).
     * @returns true if the tokens represent the same underlying asset
     */
    isFungibleWith(token?: IToken): boolean;
}
//# sourceMappingURL=Token.d.ts.map
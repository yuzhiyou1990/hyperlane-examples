import { Contract, PopulatedTransaction, ethers } from 'ethers';
import { Logger } from 'pino';
import { ITransparentUpgradeableProxy, MailboxClient, Ownable, ProxyAdmin, TimelockController } from '@hyperlane-xyz/core';
import { Address } from '@hyperlane-xyz/utils';
import { HyperlaneAddressesMap, HyperlaneContracts, HyperlaneContractsMap, HyperlaneFactories } from '../contracts/types.js';
import { HookConfig } from '../hook/types.js';
import type { HyperlaneIsmFactory } from '../ism/HyperlaneIsmFactory.js';
import { IsmConfig } from '../ism/types.js';
import { InterchainAccount } from '../middleware/account/InterchainAccount.js';
import { MultiProvider } from '../providers/MultiProvider.js';
import { MailboxClientConfig } from '../router/types.js';
import { ChainMap, ChainName } from '../types.js';
import { UpgradeConfig } from './proxy.js';
import { OwnableConfig } from './types.js';
import { ContractVerifier } from './verify/ContractVerifier.js';
import { ContractVerificationInput } from './verify/types.js';
export interface DeployerOptions {
    logger?: Logger;
    chainTimeoutMs?: number;
    ismFactory?: HyperlaneIsmFactory;
    icaApp?: InterchainAccount;
    contractVerifier?: ContractVerifier;
    concurrentDeploy?: boolean;
}
export declare abstract class HyperlaneDeployer<Config, Factories extends HyperlaneFactories> {
    protected readonly multiProvider: MultiProvider;
    protected readonly factories: Factories;
    protected readonly options: DeployerOptions;
    protected readonly recoverVerificationInputs: boolean;
    protected readonly icaAddresses: {};
    verificationInputs: ChainMap<ContractVerificationInput[]>;
    cachedAddresses: HyperlaneAddressesMap<any>;
    deployedContracts: HyperlaneContractsMap<Factories>;
    protected cachingEnabled: boolean;
    protected logger: Logger;
    chainTimeoutMs: number;
    constructor(multiProvider: MultiProvider, factories: Factories, options?: DeployerOptions, recoverVerificationInputs?: boolean, icaAddresses?: {});
    cacheAddressesMap(addressesMap: HyperlaneAddressesMap<any>): void;
    verifyContract(chain: ChainName, input: ContractVerificationInput, logger?: Logger): Promise<void>;
    abstract deployContracts(chain: ChainName, config: Config): Promise<HyperlaneContracts<Factories>>;
    deploy(configMap: ChainMap<Config>): Promise<HyperlaneContractsMap<Factories>>;
    protected addDeployedContracts(chain: ChainName, contracts: HyperlaneContracts<any>, verificationInputs?: ContractVerificationInput[]): void;
    protected addVerificationArtifacts(chain: ChainName, artifacts: ContractVerificationInput[]): void;
    protected runIf<T>(chain: ChainName, address: string, fn: () => Promise<T>, label?: string): Promise<T | undefined>;
    protected runIfOwner<T>(chain: ChainName, ownable: Ownable, fn: () => Promise<T>): Promise<T | undefined>;
    protected runIfAdmin<T>(chain: ChainName, proxy: Contract, signerAdminFn: () => Promise<T>, proxyAdminOwnerFn: (proxyAdmin: ProxyAdmin) => Promise<T>): Promise<T | undefined>;
    protected configureIsm<C extends Ownable>(chain: ChainName, contract: C, config: IsmConfig, getIsm: (contract: C) => Promise<Address>, setIsm: (contract: C, ism: Address) => Promise<PopulatedTransaction>): Promise<void>;
    protected configureHook<C extends Ownable>(chain: ChainName, contract: C, config: HookConfig, getHook: (contract: C) => Promise<Address>, setHook: (contract: C, hook: Address) => Promise<PopulatedTransaction>): Promise<void>;
    protected configureClient(local: ChainName, client: MailboxClient, config: MailboxClientConfig): Promise<void>;
    deployContractFromFactory<F extends ethers.ContractFactory>(chain: ChainName, factory: F, contractName: string, constructorArgs: Parameters<F['deploy']>, initializeArgs?: Parameters<Awaited<ReturnType<F['deploy']>>['initialize']>, shouldRecover?: boolean, implementationAddress?: Address): Promise<ReturnType<F['deploy']>>;
    /**
     * Deploys a contract with a specified name.
     *
     * This is a generic function capable of deploying any contract type, defined within the `Factories` type, to a specified chain.
     *
     * @param {ChainName} chain - The name of the chain on which the contract is to be deployed.
     * @param {K} contractKey - The key identifying the factory to use for deployment.
     * @param {string} contractName - The name of the contract to deploy. This must match the contract source code.
     * @param {Parameters<Factories[K]['deploy']>} constructorArgs - Arguments for the contract's constructor.
     * @param {Parameters<Awaited<ReturnType<Factories[K]['deploy']>>['initialize']>?} initializeArgs - Optional arguments for the contract's initialization function.
     * @param {boolean} shouldRecover - Flag indicating whether to attempt recovery if deployment fails.
     * @returns {Promise<HyperlaneContracts<Factories>[K]>} A promise that resolves to the deployed contract instance.
     */
    deployContractWithName<K extends keyof Factories>(chain: ChainName, contractKey: K, contractName: string, constructorArgs: Parameters<Factories[K]['deploy']>, initializeArgs?: Parameters<Awaited<ReturnType<Factories[K]['deploy']>>['initialize']>, shouldRecover?: boolean): Promise<HyperlaneContracts<Factories>[K]>;
    deployContract<K extends keyof Factories>(chain: ChainName, contractKey: K, constructorArgs: Parameters<Factories[K]['deploy']>, initializeArgs?: Parameters<Awaited<ReturnType<Factories[K]['deploy']>>['initialize']>, shouldRecover?: boolean): Promise<HyperlaneContracts<Factories>[K]>;
    protected changeAdmin(chain: ChainName, proxy: ITransparentUpgradeableProxy, admin: string): Promise<void>;
    protected upgradeAndInitialize<C extends ethers.Contract>(chain: ChainName, proxy: ITransparentUpgradeableProxy, implementation: C, initializeArgs: Parameters<C['initialize']>): Promise<void>;
    protected deployProxy<C extends ethers.Contract>(chain: ChainName, implementation: C, proxyAdmin: string, initializeArgs?: Parameters<C['initialize']>): Promise<C>;
    deployTimelock(chain: ChainName, timelockConfig: UpgradeConfig['timelock']): Promise<TimelockController>;
    writeCache<K extends keyof Factories>(chain: ChainName, contractName: K, address: Address): void;
    readCache<F extends ethers.ContractFactory>(chain: ChainName, factory: F, contractName: string): Awaited<ReturnType<F['deploy']>> | undefined;
    recoverVerificationArtifacts<C extends ethers.Contract>(chain: ChainName, contractName: string, cachedContract: C, constructorArgs: Parameters<C['deploy']>, initializeArgs?: Parameters<C['initialize']>): Promise<ContractVerificationInput[]>;
    /**
     * Deploys the Implementation and Proxy for a given contract
     *
     */
    deployProxiedContract<K extends keyof Factories>(chain: ChainName, contractKey: K, contractName: string, proxyAdmin: string, constructorArgs: Parameters<Factories[K]['deploy']>, initializeArgs?: Parameters<HyperlaneContracts<Factories>[K]['initialize']>): Promise<HyperlaneContracts<Factories>[K]>;
    mergeWithExistingVerificationInputs(existingInputsMap: ChainMap<ContractVerificationInput[]>): ChainMap<ContractVerificationInput[]>;
    transferOwnershipOfContracts(chain: ChainName, config: OwnableConfig, ownables: Partial<Record<string, Ownable>>): Promise<ethers.ContractReceipt[]>;
}
//# sourceMappingURL=HyperlaneDeployer.d.ts.map
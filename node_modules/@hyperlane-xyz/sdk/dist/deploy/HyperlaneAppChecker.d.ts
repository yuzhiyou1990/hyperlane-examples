import { Ownable } from '@hyperlane-xyz/core';
import { Address } from '@hyperlane-xyz/utils';
import { HyperlaneApp } from '../app/HyperlaneApp.js';
import { MultiProvider } from '../providers/MultiProvider.js';
import { ChainMap, ChainName } from '../types.js';
import { UpgradeConfig } from './proxy.js';
import { CheckerViolation } from './types.js';
export declare abstract class HyperlaneAppChecker<App extends HyperlaneApp<any>, Config> {
    readonly multiProvider: MultiProvider;
    readonly app: App;
    readonly configMap: ChainMap<Config>;
    readonly violations: CheckerViolation[];
    constructor(multiProvider: MultiProvider, app: App, configMap: ChainMap<Config>);
    abstract checkChain(chain: ChainName): Promise<void>;
    check(chainsToCheck?: ChainName[]): Promise<void[]>;
    addViolation(violation: CheckerViolation): void;
    checkProxiedContracts(chain: ChainName, owner: Address, ownableOverrides?: Record<string, Address>): Promise<void>;
    checkUpgrade(chain: ChainName, upgradeConfig: UpgradeConfig): Promise<void>;
    private removeBytecodeMetadata;
    protected getOwner(owner: Address, contractName: string, ownableOverrides?: Record<string, Address>): Address;
    checkBytecode(chain: ChainName, name: string, address: string, expectedBytecodeHashes: string[], modifyBytecodePriorToHash?: (bytecode: string) => string): Promise<void>;
    protected checkProxy(chain: ChainName, name: string, address: string): Promise<void>;
    ownables(chain: ChainName): Promise<{
        [key: string]: Ownable;
    }>;
    protected checkOwnership(chain: ChainName, owner: Address, ownableOverrides?: Record<string, Address>): Promise<void>;
    expectViolations(violationCounts: Record<string, number>): void;
    expectEmpty(): void;
    logViolationsTable(): void;
}
//# sourceMappingURL=HyperlaneAppChecker.d.ts.map
import { Logger } from 'pino';
import { Address, HexString, ProtocolType } from '@hyperlane-xyz/utils';
import { ChainMetadataManager } from '../metadata/ChainMetadataManager.js';
import type { ChainMetadata } from '../metadata/chainMetadataTypes.js';
import type { ChainMap, ChainName, ChainNameOrId } from '../types.js';
import { MultiProvider, MultiProviderOptions } from './MultiProvider.js';
import { CosmJsProvider, CosmJsWasmProvider, EthersV5Provider, ProviderMap, ProviderType, SolanaWeb3Provider, TypedProvider, TypedTransaction, ViemProvider } from './ProviderType.js';
import { ProviderBuilderMap } from './providerBuilders.js';
import { TransactionFeeEstimate } from './transactionFeeEstimators.js';
export interface MultiProtocolProviderOptions {
    logger?: Logger;
    providers?: ChainMap<ProviderMap<TypedProvider>>;
    providerBuilders?: Partial<ProviderBuilderMap>;
}
/**
 * A version of MultiProvider that can support different
 * provider types across different protocol types.
 *
 * This uses a different interface for provider/signer related methods
 * so it isn't strictly backwards compatible with MultiProvider.
 *
 * Unlike MultiProvider, this class does not support signer/signing methods (yet).
 * @typeParam MetaExt - Extra metadata fields for chains (such as contract addresses)
 */
export declare class MultiProtocolProvider<MetaExt = {}> extends ChainMetadataManager<MetaExt> {
    protected readonly options: MultiProtocolProviderOptions;
    protected readonly providers: ChainMap<ProviderMap<TypedProvider>>;
    protected signers: ChainMap<ProviderMap<never>>;
    protected readonly providerBuilders: Partial<ProviderBuilderMap>;
    readonly logger: Logger;
    constructor(chainMetadata: ChainMap<ChainMetadata<MetaExt>>, options?: MultiProtocolProviderOptions);
    static fromMultiProvider<MetaExt = {}>(mp: MultiProvider<MetaExt>, options?: MultiProtocolProviderOptions): MultiProtocolProvider<MetaExt>;
    toMultiProvider(options?: MultiProviderOptions): MultiProvider<MetaExt>;
    extendChainMetadata<NewExt = {}>(additionalMetadata: ChainMap<NewExt>): MultiProtocolProvider<MetaExt & NewExt>;
    tryGetProvider(chainNameOrId: ChainNameOrId, type?: ProviderType): TypedProvider | null;
    getProvider(chainNameOrId: ChainNameOrId, type?: ProviderType): TypedProvider;
    protected getSpecificProvider<T>(chainNameOrId: ChainNameOrId, type: ProviderType): T;
    getEthersV5Provider(chainNameOrId: ChainNameOrId): EthersV5Provider['provider'];
    getViemProvider(chainNameOrId: ChainNameOrId): ViemProvider['provider'];
    getSolanaWeb3Provider(chainNameOrId: ChainNameOrId): SolanaWeb3Provider['provider'];
    getCosmJsProvider(chainNameOrId: ChainNameOrId): CosmJsProvider['provider'];
    getCosmJsWasmProvider(chainNameOrId: ChainNameOrId): CosmJsWasmProvider['provider'];
    setProvider(chainNameOrId: ChainNameOrId, provider: TypedProvider): TypedProvider;
    setProviders(providers: ChainMap<TypedProvider>): void;
    estimateTransactionFee({ chainNameOrId, transaction, sender, senderPubKey, }: {
        chainNameOrId: ChainNameOrId;
        transaction: TypedTransaction;
        sender: Address;
        senderPubKey?: HexString;
    }): Promise<TransactionFeeEstimate>;
    intersect(chains: ChainName[], throwIfNotSubset?: boolean): {
        intersection: ChainName[];
        result: MultiProtocolProvider<MetaExt>;
    };
    /**
     * Creates a MultiProvider for test networks
     */
    static createTestMultiProtocolProvider<MetaExt = {}>(metadata?: ChainMap<ChainMetadata>, providers?: Partial<Record<ProtocolType, TypedProvider>>): MultiProtocolProvider<MetaExt>;
}
//# sourceMappingURL=MultiProtocolProvider.d.ts.map
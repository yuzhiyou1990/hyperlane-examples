import { ProtocolType, assert, convertToProtocolAddress, isValidAddress, isZeroishAddress, rootLogger } from '@hyperlane-xyz/utils';
import { estimateTransactionFeeEthersV5ForGasUnits, } from '../providers/transactionFeeEstimators.js';
import { Token } from '../token/Token.js';
import { TokenAmount } from '../token/TokenAmount.js';
import { parseTokenConnectionId } from '../token/TokenConnection.js';
import { TOKEN_STANDARD_TO_PROVIDER_TYPE, TokenStandard } from '../token/TokenStandard.js';
import { EVM_TRANSFER_REMOTE_GAS_ESTIMATE } from '../token/adapters/EvmTokenAdapter.js';
import { WarpCoreConfigSchema, WarpTxCategory, } from './types.js';
export class WarpCore {
    multiProvider;
    tokens;
    localFeeConstants;
    interchainFeeConstants;
    routeBlacklist;
    logger;
    constructor(multiProvider, tokens, options) {
        this.multiProvider = multiProvider;
        this.tokens = tokens;
        this.localFeeConstants = options?.localFeeConstants || [];
        this.interchainFeeConstants = options?.interchainFeeConstants || [];
        this.routeBlacklist = options?.routeBlacklist || [];
        this.logger =
            options?.logger ||
                rootLogger.child({
                    module: 'WarpCore',
                });
    }
    /**
     * Takes the serialized representation of a warp config and returns a WarpCore instance
     * @param multiProvider the MultiProtocolProvider containing chain metadata
     * @param config the config object of type WarpCoreConfig
     */
    static FromConfig(multiProvider, config) {
        // Validate and parse config data
        const parsedConfig = WarpCoreConfigSchema.parse(config);
        // Instantiate all tokens
        const tokens = parsedConfig.tokens.map((t) => new Token({
            ...t,
            addressOrDenom: t.addressOrDenom || '',
            connections: undefined,
        }));
        // Connect tokens together
        parsedConfig.tokens.forEach((config, i) => {
            for (const connection of config.connections || []) {
                const token1 = tokens[i];
                const { chainName, addressOrDenom } = parseTokenConnectionId(connection.token);
                const token2 = tokens.find((t) => t.chainName === chainName && t.addressOrDenom === addressOrDenom);
                assert(token2, `Connected token not found: ${chainName} ${addressOrDenom}`);
                token1.addConnection({
                    ...connection,
                    token: token2,
                });
            }
        });
        // Create new Warp
        return new WarpCore(multiProvider, tokens, parsedConfig.options);
    }
    /**
     * Queries the token router for an interchain gas quote (i.e. IGP fee)
     */
    async getInterchainTransferFee({ originToken, destination, }) {
        this.logger.debug(`Fetching interchain transfer quote to ${destination}`);
        const { chainName: originName } = originToken;
        const destinationName = this.multiProvider.getChainName(destination);
        let gasAmount;
        let gasAddressOrDenom;
        // Check constant quotes first
        const defaultQuote = this.interchainFeeConstants.find((q) => q.origin.split('101010').includes(originName) &&
            q.destination.split('101010').includes(destinationName));
        if (defaultQuote) {
            gasAmount = BigInt(defaultQuote.amount.toString());
            gasAddressOrDenom = defaultQuote.addressOrDenom;
        }
        else {
            // Otherwise, compute IGP quote via the adapter
            const hypAdapter = originToken.getAdapter(this.multiProvider);
            const destinationDomainId = this.multiProvider.getDomainId(destination);
            const quote = await hypAdapter.quoteTransferRemoteGas(destinationDomainId);
            gasAmount = BigInt(quote.amount);
            gasAddressOrDenom = quote.addressOrDenom;
        }
        let igpToken;
        if (!gasAddressOrDenom) {
            // An empty/undefined addressOrDenom indicates the native token
            igpToken = Token.FromChainMetadataNativeToken(this.multiProvider.getChainMetadata(originName));
        }
        else {
            const searchResult = this.findToken(originName, gasAddressOrDenom);
            assert(searchResult, `Fee token ${gasAddressOrDenom} is unknown`);
            igpToken = searchResult;
        }
        this.logger.debug(`Quoted interchain transfer fee: ${gasAmount} ${igpToken.symbol}`);
        return new TokenAmount(gasAmount, igpToken);
    }
    /**
     * Simulates a transfer to estimate 'local' gas fees on the origin chain
     */
    async getLocalTransferFee({ originToken, destination, sender, senderPubKey, interchainFee, }) {
        this.logger.debug(`Estimating local transfer gas to ${destination}`);
        const originMetadata = this.multiProvider.getChainMetadata(originToken.chainName);
        const destinationMetadata = this.multiProvider.getChainMetadata(destination);
        // Check constant quotes first
        const defaultQuote = this.localFeeConstants.find((q) => q.origin === originMetadata.name &&
            q.destination === destinationMetadata.name);
        if (defaultQuote) {
            return { gasUnits: 0, gasPrice: 0, fee: Number(defaultQuote.amount) };
        }
        // Form transactions to estimate local gas with
        const recipient = convertToProtocolAddress(sender, destinationMetadata.protocol, destinationMetadata.bech32Prefix);
        const txs = await this.getTransferRemoteTxs({
            originTokenAmount: originToken.amount(1),
            destination,
            sender,
            recipient,
            interchainFee,
        });
        // Typically the transfers require a single transaction
        if (txs.length === 1) {
            try {
                return this.multiProvider.estimateTransactionFee({
                    chainNameOrId: originMetadata.name,
                    transaction: txs[0],
                    sender,
                    senderPubKey,
                });
            }
            catch (error) {
                this.logger.error(`Failed to estimate local gas fee for ${originToken.symbol} transfer`, error);
                throw new Error('Gas estimation failed, balance may be insufficient', {
                    cause: error,
                });
            }
        }
        // On ethereum, sometimes 2 txs are required (one approve, one transferRemote)
        else if (txs.length === 2 &&
            originToken.protocol === ProtocolType.Ethereum) {
            const provider = this.multiProvider.getEthersV5Provider(originMetadata.name);
            // We use a hard-coded const as an estimate for the transferRemote because we
            // cannot reliably simulate the tx when an approval tx is required first
            return estimateTransactionFeeEthersV5ForGasUnits({
                provider,
                gasUnits: EVM_TRANSFER_REMOTE_GAS_ESTIMATE,
            });
        }
        else {
            throw new Error('Cannot estimate local gas for multiple transactions');
        }
    }
    /**
     * Similar to getLocalTransferFee in that it estimates local gas fees
     * but it also resolves the native token and returns a TokenAmount
     * @todo: rename to getLocalTransferFee for consistency (requires breaking change)
     */
    async getLocalTransferFeeAmount({ originToken, destination, sender, senderPubKey, interchainFee, }) {
        const originMetadata = this.multiProvider.getChainMetadata(originToken.chainName);
        // If there's no native token, we can't represent local gas
        if (!originMetadata.nativeToken)
            throw new Error(`No native token found for ${originMetadata.name}`);
        this.logger.debug(`Using native token ${originMetadata.nativeToken.symbol} for local gas fee`);
        const localFee = await this.getLocalTransferFee({
            originToken,
            destination,
            sender,
            senderPubKey,
            interchainFee,
        });
        // Get the local gas token. This assumes the chain's native token will pay for local gas
        // This will need to be smarter if more complex scenarios on Cosmos are supported
        const localGasToken = Token.FromChainMetadataNativeToken(originMetadata);
        return localGasToken.amount(localFee.fee);
    }
    /**
     * Gets a list of populated transactions required to transfer a token to a remote chain
     * Typically just 1 transaction but sometimes more, like when an approval is required first
     */
    async getTransferRemoteTxs({ originTokenAmount, destination, sender, recipient, interchainFee, }) {
        const transactions = [];
        const { token, amount } = originTokenAmount;
        const destinationDomainId = this.multiProvider.getDomainId(destination);
        const providerType = TOKEN_STANDARD_TO_PROVIDER_TYPE[token.standard];
        const adapter = token.getAdapter(this.multiProvider);
        if (await this.isApproveRequired({ originTokenAmount, owner: sender })) {
            this.logger.info(`Approval required for transfer of ${token.symbol}`);
            const approveTxReq = await adapter.populateApproveTx({
                weiAmountOrId: amount.toString(),
                recipient: token.collateralAddressOrDenom,
            });
            this.logger.debug(`Approval tx for ${token.symbol} populated`);
            const approveTx = {
                category: WarpTxCategory.Approval,
                type: providerType,
                transaction: approveTxReq,
            };
            transactions.push(approveTx);
        }

        const outputToken = token.getConnections().find((c) => c.token.chainName === destination)

        const transferTxReq = await adapter.populateOpenOrderTx({
            sender,
            recipient,
            outputToken: outputToken.token.addressOrDenom,
            destinationSettler: outputToken.token.collateralAddressOrDenom,
            amountIn: amount.toString(),
            amountOut: (amount === 1n ? amount : amount - interchainFee.amount).toString(),
            destinationDomain: `${destinationDomainId}`,
            fillDeadline: `${Math.floor(Date.now() / 1000) + 60 * 60}`,
        });
        this.logger.debug(`Remote transfer tx for ${token.symbol} populated`);
        const transferTx = {
            category: WarpTxCategory.Transfer,
            type: providerType,
            transaction: transferTxReq,
        };
        transactions.push(transferTx);
        return transactions;
    }
    /**
     * Fetch local and interchain fee estimates for a remote transfer
     */
    async estimateTransferRemoteFees({ originToken, destination, sender, senderPubKey, }) {
        this.logger.debug('Fetching remote transfer fee estimates');
        // First get interchain gas quote (aka IGP quote)
        // Start with this because it's used in the local fee estimation
        const interchainQuote = await this.getInterchainTransferFee({
            originToken,
            destination,
        });
        // Next, get the local gas quote
        const localQuote = await this.getLocalTransferFeeAmount({
            originToken,
            destination,
            sender,
            senderPubKey,
            interchainFee: interchainQuote,
        });
        return {
            interchainQuote,
            localQuote,
        };
    }
    /**
     * Computes the max transferrable amount of the from the given
     * token balance, accounting for local and interchain gas fees
     */
    async getMaxTransferAmount({ balance, destination, sender, senderPubKey, feeEstimate, topMax, }) {
        const originToken = balance.token;
        if (!feeEstimate) {
            feeEstimate = await this.estimateTransferRemoteFees({
                originToken,
                destination,
                sender,
                senderPubKey,
            });
        }
        const { localQuote, interchainQuote } = feeEstimate;
        let maxAmount = balance;
        if (originToken.isFungibleWith(localQuote.token)) {
            maxAmount = maxAmount.minus(localQuote.amount);
        }
        if (originToken.isFungibleWith(interchainQuote.token)) {
            if (topMax !== undefined && maxAmount.amount > originToken.amount(topMax).plus(interchainQuote.amount).amount) {
                maxAmount = originToken.amount(topMax);
            } else
                maxAmount = maxAmount.minus(interchainQuote.amount);
        }
        if (maxAmount.amount > 0)
            return maxAmount;
        else
            return originToken.amount(0);
    }
    /**
     * Checks if destination chain's collateral is sufficient to cover the transfer
     */
    async isDestinationCollateralSufficient({ originTokenAmount, destination, }) {
        return true;
    }
    /**
     * Checks if a token transfer requires an approval tx first
     */
    async isApproveRequired({ originTokenAmount, owner, }) {
        const { token, amount } = originTokenAmount;
        const adapter = token.getAdapter(this.multiProvider);
        const isRequired = await adapter.isApproveRequired(owner, token.collateralAddressOrDenom, amount);
        this.logger.debug(`Approval is${isRequired ? '' : ' not'} required for transfer of ${token.symbol}`);
        return isRequired;
    }
    /**
     * Ensure the remote token transfer would be valid for the given chains, amount, sender, and recipient
     */
    async validateTransfer({ originTokenAmount, destination, recipient, sender, senderPubKey, topMax }) {
        const chainError = this.validateChains(originTokenAmount.token.chainName, destination);
        if (chainError)
            return chainError;
        const recipientError = this.validateRecipient(recipient, destination);
        if (recipientError)
            return recipientError;
        const balancesError = await this.validateTokenBalances(originTokenAmount, destination, sender, senderPubKey, topMax);
        if (balancesError)
            return balancesError;
        return null;
    }
    /**
     * Ensure the origin and destination chains are valid and known by this WarpCore
     */
    validateChains(origin, destination) {
        if (!origin)
            return { origin: 'Origin chain required' };
        if (!destination)
            return { destination: 'Destination chain required' };
        const originMetadata = this.multiProvider.tryGetChainMetadata(origin);
        const destinationMetadata = this.multiProvider.tryGetChainMetadata(destination);
        if (!originMetadata)
            return { origin: 'Origin chain metadata missing' };
        if (!destinationMetadata)
            return { destination: 'Destination chain metadata missing' };
        if (this.routeBlacklist.some((bl) => bl.origin === originMetadata.name &&
            bl.destination === destinationMetadata.name)) {
            return { destination: 'Route is not currently allowed' };
        }
        return null;
    }
    /**
     * Ensure recipient address is valid for the destination chain
     */
    validateRecipient(recipient, destination) {
        const destinationMetadata = this.multiProvider.getChainMetadata(destination);
        const { protocol, bech32Prefix } = destinationMetadata;
        // Ensure recip address is valid for the destination chain's protocol
        if (!isValidAddress(recipient, protocol) || isZeroishAddress(recipient))
            return { recipient: 'Invalid recipient' };
        // Also ensure the address denom is correct if the dest protocol is Cosmos
        if (protocol === ProtocolType.Cosmos) {
            if (!bech32Prefix) {
                this.logger.error(`No bech32 prefix found for chain ${destination}`);
                return { destination: 'Invalid chain data' };
            }
            else if (!recipient.startsWith(bech32Prefix)) {
                this.logger.error(`Recipient prefix should be ${bech32Prefix}`);
                return { recipient: 'Invalid recipient prefix' };
            }
        }
        return null;
    }
    /**
     * Ensure token amount is valid
     */
    validateAmount(originTokenAmount) {
        if (!originTokenAmount.amount || originTokenAmount.amount < 0n) {
            const isNft = originTokenAmount.token.isNft();
            return { amount: isNft ? 'Invalid Token Id' : 'Invalid amount' };
        }
        return null;
    }

    /**
   * Ensure the sender has sufficient balances for transfer and interchain gas
   */
  async validateTokenBalances(
    originTokenAmount,
    destination,
    sender,
    senderPubKey,
    topMax
  ) {
    const { token: originToken, amount } = originTokenAmount

    const { amount: senderBalance } = await originToken.getBalance(
      this.multiProvider,
      sender
    )
    const senderBalanceAmount = originTokenAmount.token.amount(senderBalance)

    // Check 1: Check basic token balance
      if (amount > senderBalance) return { amount: "Insufficient balance" }
      if (amount > topMax) return { amount: `Amount exceeds ${topMax * 10 ** -6} USDC` }

    // Check 2: Ensure the balance can cover interchain fee
    // Slightly redundant with Check 4 but gives more specific error messages
    const interchainQuote = await this.getInterchainTransferFee({
      originToken,
      destination,
      sender
    })
    // Get balance of the IGP fee token, which may be different from the transfer token
    const interchainQuoteTokenBalance = originToken.isFungibleWith(
      interchainQuote.token
    )
      ? senderBalanceAmount
      : await interchainQuote.token.getBalance(this.multiProvider, sender)
    if (interchainQuoteTokenBalance.amount < interchainQuote.amount) {
      return {
        amount: `Insufficient ${interchainQuote.token.symbol} for interchain gas`
      }
    }

    // Check 3: Simulates the transfer by getting the local gas fee
    const localQuote = await this.getLocalTransferFeeAmount({
      originToken,
      destination,
      sender,
      senderPubKey,
      interchainFee: interchainQuote
    })

    const feeEstimate = { interchainQuote, localQuote }

    // Check 4: Ensure balances can cover the COMBINED amount and fees
    const maxTransfer = await this.getMaxTransferAmount({
      balance: senderBalanceAmount,
      destination,
      sender,
      senderPubKey,
      feeEstimate
    })
    if (amount > maxTransfer.amount) {
      return { amount: "Insufficient balance for gas and transfer" }
    }

    return null
  }

    /**
     * Ensure the sender has sufficient balances for transfer and interchain gas
     */
    async validateDestinationCollateral(originTokenAmount, destination) {
        const valid = await this.isDestinationCollateralSufficient({
            originTokenAmount,
            destination,
        });
        if (!valid)
            return { amount: 'Insufficient collateral on destination' };
        return null;
    }
    /**
     * Ensure the sender has sufficient balances for transfer and interchain gas
     */
    async validateOriginCollateral(originTokenAmount) {
        const adapter = originTokenAmount.token.getAdapter(this.multiProvider);
        if (originTokenAmount.token.standard === TokenStandard.EvmHypXERC20 ||
            originTokenAmount.token.standard === TokenStandard.EvmHypXERC20Lockbox) {
            const burnLimit = await adapter.getBurnLimit();
            if (burnLimit < BigInt(originTokenAmount.amount)) {
                return { amount: 'Insufficient burn limit on origin' };
            }
        }
        return null;
    }
    /**
     * Search through token list to find token with matching chain and address
     */
    findToken(chainName, addressOrDenom) {
        if (!addressOrDenom)
            return null;
        const results = this.tokens.filter((token) => token.chainName === chainName &&
            token.addressOrDenom.toLowerCase() === addressOrDenom.toLowerCase());
        if (results.length === 1)
            return results[0];
        if (results.length > 1)
            throw new Error(`Ambiguous token search results for ${addressOrDenom}`);
        // If the token is not found, check to see if it matches the denom of chain's native token
        // This is a convenience so WarpConfigs don't need to include definitions for native tokens
        const chainMetadata = this.multiProvider.getChainMetadata(chainName);
        if (chainMetadata.nativeToken?.denom === addressOrDenom) {
            return Token.FromChainMetadataNativeToken(chainMetadata);
        }
        return null;
    }
    /**
     * Get the list of chains referenced by the tokens in this WarpCore
     */
    getTokenChains() {
        return [...new Set(this.tokens.map((t) => t.chainName)).values()];
    }
    /**
     * Get the subset of tokens whose chain matches the given chainName
     */
    getTokensForChain(chainName) {
        return this.tokens.filter((t) => t.chainName === chainName);
    }
    /**
     * Get the subset of tokens whose chain matches the given chainName
     * and which are connected to a token on the given destination chain
     */
    getTokensForRoute(origin, destination) {
        return this.tokens.filter((t) => t.chainName === origin && t.getConnectionForChain(destination));
    }
}
//# sourceMappingURL=WarpCore.js.map
import { Address, HexString } from '@hyperlane-xyz/utils';
import { Logger } from 'pino';
import { MultiProtocolProvider } from '../providers/MultiProtocolProvider.js';
import { TransactionFeeEstimate } from '../providers/transactionFeeEstimators.js';
import { IToken } from '../token/IToken.js';
import { Token } from '../token/Token.js';
import { TokenAmount } from '../token/TokenAmount.js';
import { ChainName, ChainNameOrId } from '../types.js';
import { FeeConstantConfig, RouteBlacklist, WarpCoreFeeEstimate, WarpTypedTransaction } from './types.js';
export interface WarpCoreOptions {
    logger?: Logger;
    localFeeConstants?: FeeConstantConfig;
    interchainFeeConstants?: FeeConstantConfig;
    routeBlacklist?: RouteBlacklist;
}
export declare class WarpCore {
    readonly multiProvider: MultiProtocolProvider<{
        mailbox?: Address;
    }>;
    readonly tokens: Token[];
    readonly localFeeConstants: FeeConstantConfig;
    readonly interchainFeeConstants: FeeConstantConfig;
    readonly routeBlacklist: RouteBlacklist;
    readonly logger: Logger;
    constructor(multiProvider: MultiProtocolProvider<{
        mailbox?: Address;
    }>, tokens: Token[], options?: WarpCoreOptions);
    /**
     * Takes the serialized representation of a warp config and returns a WarpCore instance
     * @param multiProvider the MultiProtocolProvider containing chain metadata
     * @param config the config object of type WarpCoreConfig
     */
    static FromConfig(multiProvider: MultiProtocolProvider<{
        mailbox?: Address;
    }>, config: unknown): WarpCore;
    /**
     * Queries the token router for an interchain gas quote (i.e. IGP fee)
     */
    getInterchainTransferFee({ originToken, destination, }: {
        originToken: IToken;
        destination: ChainNameOrId;
    }): Promise<TokenAmount>;
    /**
     * Simulates a transfer to estimate 'local' gas fees on the origin chain
     */
    getLocalTransferFee({ originToken, destination, sender, senderPubKey, interchainFee, }: {
        originToken: IToken;
        destination: ChainNameOrId;
        sender: Address;
        senderPubKey?: HexString;
        interchainFee?: TokenAmount;
    }): Promise<TransactionFeeEstimate>;
    /**
     * Similar to getLocalTransferFee in that it estimates local gas fees
     * but it also resolves the native token and returns a TokenAmount
     * @todo: rename to getLocalTransferFee for consistency (requires breaking change)
     */
    getLocalTransferFeeAmount({ originToken, destination, sender, senderPubKey, interchainFee, }: {
        originToken: IToken;
        destination: ChainNameOrId;
        sender: Address;
        senderPubKey?: HexString;
        interchainFee?: TokenAmount;
    }): Promise<TokenAmount>;
    /**
     * Gets a list of populated transactions required to transfer a token to a remote chain
     * Typically just 1 transaction but sometimes more, like when an approval is required first
     */
    getTransferRemoteTxs({ originTokenAmount, destination, sender, recipient, interchainFee, }: {
        originTokenAmount: TokenAmount;
        destination: ChainNameOrId;
        sender: Address;
        recipient: Address;
        interchainFee?: TokenAmount;
    }): Promise<Array<WarpTypedTransaction>>;
    /**
     * Fetch local and interchain fee estimates for a remote transfer
     */
    estimateTransferRemoteFees({ originToken, destination, sender, senderPubKey, }: {
        originToken: IToken;
        destination: ChainNameOrId;
        sender: Address;
        senderPubKey?: HexString;
    }): Promise<WarpCoreFeeEstimate>;
    /**
     * Computes the max transferrable amount of the from the given
     * token balance, accounting for local and interchain gas fees
     */
    getMaxTransferAmount({ balance, destination, sender, senderPubKey, feeEstimate, topMax }: {
        balance: TokenAmount;
        destination: ChainNameOrId;
        sender: Address;
        senderPubKey?: HexString;
        feeEstimate?: WarpCoreFeeEstimate;
        topMax?: number;
    }): Promise<TokenAmount>;
    /**
     * Checks if destination chain's collateral is sufficient to cover the transfer
     */
    isDestinationCollateralSufficient({ originTokenAmount, destination, }: {
        originTokenAmount: TokenAmount;
        destination: ChainNameOrId;
    }): Promise<boolean>;
    /**
     * Checks if a token transfer requires an approval tx first
     */
    isApproveRequired({ originTokenAmount, owner, }: {
        originTokenAmount: TokenAmount;
        owner: Address;
    }): Promise<boolean>;
    /**
     * Ensure the remote token transfer would be valid for the given chains, amount, sender, and recipient
     */
    validateTransfer({ originTokenAmount, destination, recipient, sender, senderPubKey, topMax }: {
        originTokenAmount: TokenAmount;
        destination: ChainNameOrId;
        recipient: Address;
        sender: Address;
        senderPubKey?: HexString;
        topMax?: number;
    }): Promise<Record<string, string> | null>;
    /**
     * Ensure the origin and destination chains are valid and known by this WarpCore
     */
    protected validateChains(origin: ChainNameOrId, destination: ChainNameOrId): Record<string, string> | null;
    /**
     * Ensure recipient address is valid for the destination chain
     */
    protected validateRecipient(recipient: Address, destination: ChainNameOrId): Record<string, string> | null;
    /**
     * Ensure token amount is valid
     */
    protected validateAmount(originTokenAmount: TokenAmount): Record<string, string> | null;
    /**
     * Ensure the sender has sufficient balances for transfer and interchain gas
     */
    protected validateTokenBalances(originTokenAmount: TokenAmount, destination: ChainNameOrId, sender: Address, senderPubKey?: HexString): Promise<Record<string, string> | null>;
    /**
     * Ensure the sender has sufficient balances for transfer and interchain gas
     */
    protected validateDestinationCollateral(originTokenAmount: TokenAmount, destination: ChainNameOrId): Promise<Record<string, string> | null>;
    /**
     * Ensure the sender has sufficient balances for transfer and interchain gas
     */
    protected validateOriginCollateral(originTokenAmount: TokenAmount): Promise<Record<string, string> | null>;
    /**
     * Search through token list to find token with matching chain and address
     */
    findToken(chainName: ChainName, addressOrDenom?: Address | string): Token | null;
    /**
     * Get the list of chains referenced by the tokens in this WarpCore
     */
    getTokenChains(): ChainName[];
    /**
     * Get the subset of tokens whose chain matches the given chainName
     */
    getTokensForChain(chainName: ChainName): Token[];
    /**
     * Get the subset of tokens whose chain matches the given chainName
     * and which are connected to a token on the given destination chain
     */
    getTokensForRoute(origin: ChainName, destination: ChainName): Token[];
}
//# sourceMappingURL=WarpCore.d.ts.map
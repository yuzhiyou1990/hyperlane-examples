import { BaseValidator, isS3CheckpointWithId, } from '@hyperlane-xyz/utils';
import { S3Wrapper } from './s3.js';
const checkpointWithMessageIdKey = (checkpointIndex) => `checkpoint_${checkpointIndex}_with_id.json`;
const LATEST_KEY = 'checkpoint_latest_index.json';
const ANNOUNCEMENT_KEY = 'announcement.json';
const LOCATION_PREFIX = 's3://';
/**
 * Extension of BaseValidator that includes AWS S3 utilities.
 */
export class S3Validator extends BaseValidator {
    validatorConfig;
    s3Config;
    s3Bucket;
    constructor(validatorConfig, s3Config) {
        super(validatorConfig);
        this.validatorConfig = validatorConfig;
        this.s3Config = s3Config;
        this.s3Bucket = new S3Wrapper(s3Config);
    }
    static async fromStorageLocation(storageLocation) {
        if (storageLocation.startsWith(LOCATION_PREFIX)) {
            const suffix = storageLocation.slice(LOCATION_PREFIX.length);
            const pieces = suffix.split('/');
            if (pieces.length >= 2) {
                const s3Config = {
                    bucket: pieces[0],
                    region: pieces[1],
                    folder: pieces.slice(2).join('/'),
                    caching: true,
                };
                const s3Bucket = new S3Wrapper(s3Config);
                const announcement = await s3Bucket.getS3Obj(ANNOUNCEMENT_KEY);
                if (!announcement) {
                    throw new Error('No announcement found');
                }
                const validatorConfig = {
                    address: announcement.data.value.validator,
                    localDomain: announcement.data.value.mailbox_domain,
                    mailbox: announcement.data.value.mailbox_address,
                };
                return new S3Validator(validatorConfig, s3Config);
            }
        }
        throw new Error(`Unable to parse location ${storageLocation}`);
    }
    async getAnnouncement() {
        const { value } = await this.getSignedAnnouncement();
        return value;
    }
    async getSignedAnnouncement() {
        const resp = await this.s3Bucket.getS3Obj(ANNOUNCEMENT_KEY);
        if (!resp) {
            throw new Error(`No announcement found for ${this.config.localDomain}`);
        }
        return resp.data;
    }
    async getCheckpoint(index) {
        const key = checkpointWithMessageIdKey(index);
        const s3Object = await this.s3Bucket.getS3Obj(key);
        if (!s3Object) {
            return;
        }
        if (isS3CheckpointWithId(s3Object.data)) {
            return s3Object.data;
        }
        else {
            throw new Error('Failed to parse checkpoint');
        }
    }
    async getLatestCheckpointIndex() {
        const latestCheckpointIndex = await this.s3Bucket.getS3Obj(LATEST_KEY);
        if (!latestCheckpointIndex)
            return -1;
        return latestCheckpointIndex.data;
    }
    storageLocation() {
        return `${LOCATION_PREFIX}/${this.s3Bucket.config.bucket}/${this.s3Bucket.config.region}`;
    }
    getLatestCheckpointUrl() {
        return this.s3Bucket.url(LATEST_KEY);
    }
}
//# sourceMappingURL=validator.js.map
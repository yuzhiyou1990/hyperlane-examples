import { PublicKey } from '@solana/web3.js';
import { ProtocolType, objMap, promiseObjAll, rootLogger, symmetricDifference, } from '@hyperlane-xyz/utils';
import { MultiGeneric } from '../utils/MultiGeneric.js';
/**
 * A minimal interface for an adapter that can be used with MultiProtocolApp
 * The purpose of adapters is to implement protocol-specific functionality
 * E.g. EvmRouterAdapter implements EVM-specific router functionality
 *   whereas SealevelRouterAdapter implements the same logic for Solana
 */
export class BaseAppAdapter {
    chainName;
    multiProvider;
    addresses;
    logger;
    constructor(chainName, multiProvider, addresses, logger = rootLogger.child({ module: `AppAdapter` })) {
        this.chainName = chainName;
        this.multiProvider = multiProvider;
        this.addresses = addresses;
        this.logger = logger;
    }
}
export class BaseEvmAdapter extends BaseAppAdapter {
    protocol = ProtocolType.Ethereum;
    getProvider() {
        return this.multiProvider.getEthersV5Provider(this.chainName);
    }
}
export class BaseCosmWasmAdapter extends BaseAppAdapter {
    protocol = ProtocolType.Cosmos;
    getProvider() {
        return this.multiProvider.getCosmJsWasmProvider(this.chainName);
    }
}
export class BaseCosmosAdapter extends BaseAppAdapter {
    protocol = ProtocolType.Cosmos;
    getProvider() {
        return this.multiProvider.getCosmJsProvider(this.chainName);
    }
}
export class BaseSealevelAdapter extends BaseAppAdapter {
    protocol = ProtocolType.Sealevel;
    getProvider() {
        return this.multiProvider.getSolanaWeb3Provider(this.chainName);
    }
    static derivePda(seeds, programId) {
        const [pda] = PublicKey.findProgramAddressSync(seeds.map((s) => Buffer.from(s)), new PublicKey(programId));
        return pda;
    }
    // An dynamic alias for static method above for convenience
    derivePda(seeds, programId) {
        return BaseSealevelAdapter.derivePda(seeds, programId);
    }
}
/**
 * A version of HyperlaneApp that can support different
 * provider types across different protocol types.
 *
 * Intentionally minimal as it's meant to be extended.
 * Extend this class as needed to add useful methods/properties.
 *
 * @typeParam ContractAddrs - A map of contract names to addresses
 * @typeParam IAdapterApi - The type of the adapters for implementing the app's
 *   functionality across different protocols.
 *
 * @param multiProvider - A MultiProtocolProvider instance that MUST include the app's
 *   contract addresses in its chain metadata
 * @param logger - A logger instance
 *
 * @override protocolToAdapter - This should return an Adapter class for a given protocol type
 */
export class MultiProtocolApp extends MultiGeneric {
    multiProvider;
    addresses;
    logger;
    constructor(multiProvider, addresses, logger = rootLogger.child({ module: 'MultiProtocolApp' })) {
        const multiProviderChains = multiProvider.getKnownChainNames();
        const addressesChains = Object.keys(addresses);
        const setDifference = symmetricDifference(new Set(multiProviderChains), new Set(addressesChains));
        if (setDifference.size > 0) {
            throw new Error(`MultiProtocolProvider and addresses must have the same chains. Provider chains: ${multiProviderChains.join(', ')}. Addresses chains: ${addressesChains.join(', ')}. Difference: ${Array.from(setDifference)}`);
        }
        super(multiProvider.metadata);
        this.multiProvider = multiProvider;
        this.addresses = addresses;
        this.logger = logger;
    }
    // Subclasses may want to override this to provide adapters more arguments
    adapter(chain) {
        const Adapter = this.protocolToAdapter(this.protocol(chain));
        return new Adapter(chain, this.multiProvider, this.addresses[chain]);
    }
    adapters() {
        return this.map((chain, _) => this.adapter(chain));
    }
    adapterMap(fn) {
        return promiseObjAll(objMap(this.adapters(), fn));
    }
    metadata(chain) {
        return this.get(chain);
    }
    protocol(chain) {
        return this.metadata(chain).protocol;
    }
    provider(chain) {
        return this.multiProvider.getProvider(chain);
    }
}
//# sourceMappingURL=MultiProtocolApp.js.map
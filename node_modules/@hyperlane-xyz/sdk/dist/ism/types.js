import { z } from 'zod';
import { ZHash } from '../metadata/customZodTypes.js';
import { OwnableSchema, PausableSchema } from '../schemas.js';
// this enum should match the IInterchainSecurityModule.sol enum
// meant for the relayer
export var ModuleType;
(function (ModuleType) {
    ModuleType[ModuleType["UNUSED"] = 0] = "UNUSED";
    ModuleType[ModuleType["ROUTING"] = 1] = "ROUTING";
    ModuleType[ModuleType["AGGREGATION"] = 2] = "AGGREGATION";
    ModuleType[ModuleType["LEGACY_MULTISIG"] = 3] = "LEGACY_MULTISIG";
    ModuleType[ModuleType["MERKLE_ROOT_MULTISIG"] = 4] = "MERKLE_ROOT_MULTISIG";
    ModuleType[ModuleType["MESSAGE_ID_MULTISIG"] = 5] = "MESSAGE_ID_MULTISIG";
    ModuleType[ModuleType["NULL"] = 6] = "NULL";
    ModuleType[ModuleType["CCIP_READ"] = 7] = "CCIP_READ";
    ModuleType[ModuleType["ARB_L2_TO_L1"] = 8] = "ARB_L2_TO_L1";
    ModuleType[ModuleType["WEIGHTED_MERKLE_ROOT_MULTISIG"] = 9] = "WEIGHTED_MERKLE_ROOT_MULTISIG";
    ModuleType[ModuleType["WEIGHTED_MESSAGE_ID_MULTISIG"] = 10] = "WEIGHTED_MESSAGE_ID_MULTISIG";
})(ModuleType || (ModuleType = {}));
// this enum can be adjusted as per deployments necessary
// meant for the deployer and checker
export var IsmType;
(function (IsmType) {
    IsmType["CUSTOM"] = "custom";
    IsmType["OP_STACK"] = "opStackIsm";
    IsmType["ROUTING"] = "domainRoutingIsm";
    IsmType["FALLBACK_ROUTING"] = "defaultFallbackRoutingIsm";
    IsmType["AGGREGATION"] = "staticAggregationIsm";
    IsmType["STORAGE_AGGREGATION"] = "storageAggregationIsm";
    IsmType["MERKLE_ROOT_MULTISIG"] = "merkleRootMultisigIsm";
    IsmType["MESSAGE_ID_MULTISIG"] = "messageIdMultisigIsm";
    IsmType["STORAGE_MERKLE_ROOT_MULTISIG"] = "storageMerkleRootMultisigIsm";
    IsmType["STORAGE_MESSAGE_ID_MULTISIG"] = "storageMessageIdMultisigIsm";
    IsmType["TEST_ISM"] = "testIsm";
    IsmType["PAUSABLE"] = "pausableIsm";
    IsmType["TRUSTED_RELAYER"] = "trustedRelayerIsm";
    IsmType["ARB_L2_TO_L1"] = "arbL2ToL1Ism";
    IsmType["WEIGHTED_MERKLE_ROOT_MULTISIG"] = "weightedMerkleRootMultisigIsm";
    IsmType["WEIGHTED_MESSAGE_ID_MULTISIG"] = "weightedMessageIdMultisigIsm";
})(IsmType || (IsmType = {}));
// ISM types that can be updated in-place
export const MUTABLE_ISM_TYPE = [
    IsmType.ROUTING,
    IsmType.FALLBACK_ROUTING,
    IsmType.PAUSABLE,
];
// mapping between the two enums
export function ismTypeToModuleType(ismType) {
    switch (ismType) {
        case IsmType.ROUTING:
            return ModuleType.ROUTING;
        case IsmType.FALLBACK_ROUTING:
            return ModuleType.ROUTING;
        case IsmType.AGGREGATION:
        case IsmType.STORAGE_AGGREGATION:
            return ModuleType.AGGREGATION;
        case IsmType.MERKLE_ROOT_MULTISIG:
        case IsmType.STORAGE_MERKLE_ROOT_MULTISIG:
            return ModuleType.MERKLE_ROOT_MULTISIG;
        case IsmType.MESSAGE_ID_MULTISIG:
        case IsmType.STORAGE_MESSAGE_ID_MULTISIG:
            return ModuleType.MESSAGE_ID_MULTISIG;
        case IsmType.OP_STACK:
        case IsmType.TEST_ISM:
        case IsmType.PAUSABLE:
        case IsmType.CUSTOM:
        case IsmType.TRUSTED_RELAYER:
            return ModuleType.NULL;
        case IsmType.ARB_L2_TO_L1:
            return ModuleType.ARB_L2_TO_L1;
        case IsmType.WEIGHTED_MERKLE_ROOT_MULTISIG:
            return ModuleType.WEIGHTED_MERKLE_ROOT_MULTISIG;
        case IsmType.WEIGHTED_MESSAGE_ID_MULTISIG:
            return ModuleType.WEIGHTED_MESSAGE_ID_MULTISIG;
    }
}
const ValidatorInfoSchema = z.object({
    signingAddress: ZHash,
    weight: z.number(),
});
export const TestIsmConfigSchema = z.object({
    type: z.literal(IsmType.TEST_ISM),
});
export const MultisigConfigSchema = z.object({
    validators: z.array(ZHash),
    threshold: z.number(),
});
export const WeightedMultisigConfigSchema = z.object({
    validators: z.array(ValidatorInfoSchema),
    thresholdWeight: z.number(),
});
export const TrustedRelayerIsmConfigSchema = z.object({
    type: z.literal(IsmType.TRUSTED_RELAYER),
    relayer: z.string(),
});
export const OpStackIsmConfigSchema = z.object({
    type: z.literal(IsmType.OP_STACK),
    origin: z.string(),
    nativeBridge: z.string(),
});
export const ArbL2ToL1IsmConfigSchema = z.object({
    type: z.literal(IsmType.ARB_L2_TO_L1),
    bridge: z.string(),
});
export const PausableIsmConfigSchema = PausableSchema.and(z.object({
    type: z.literal(IsmType.PAUSABLE),
}));
export const MultisigIsmConfigSchema = MultisigConfigSchema.and(z.object({
    type: z.union([
        z.literal(IsmType.MERKLE_ROOT_MULTISIG),
        z.literal(IsmType.MESSAGE_ID_MULTISIG),
        z.literal(IsmType.STORAGE_MERKLE_ROOT_MULTISIG),
        z.literal(IsmType.STORAGE_MESSAGE_ID_MULTISIG),
    ]),
}));
export const WeightedMultisigIsmConfigSchema = WeightedMultisigConfigSchema.and(z.object({
    type: z.union([
        z.literal(IsmType.WEIGHTED_MERKLE_ROOT_MULTISIG),
        z.literal(IsmType.WEIGHTED_MESSAGE_ID_MULTISIG),
    ]),
}));
export const RoutingIsmConfigSchema = z.lazy(() => OwnableSchema.extend({
    type: z.union([
        z.literal(IsmType.ROUTING),
        z.literal(IsmType.FALLBACK_ROUTING),
    ]),
    domains: z.record(IsmConfigSchema),
}));
export const AggregationIsmConfigSchema = z
    .lazy(() => z.object({
    type: z.literal(IsmType.AGGREGATION),
    modules: z.array(IsmConfigSchema),
    threshold: z.number(),
}))
    .refine((data) => data.threshold <= data.modules.length, {
    message: 'Threshold must be less than or equal to the number of modules',
});
export const IsmConfigSchema = z.union([
    ZHash,
    TestIsmConfigSchema,
    OpStackIsmConfigSchema,
    PausableIsmConfigSchema,
    TrustedRelayerIsmConfigSchema,
    MultisigIsmConfigSchema,
    WeightedMultisigIsmConfigSchema,
    RoutingIsmConfigSchema,
    AggregationIsmConfigSchema,
    ArbL2ToL1IsmConfigSchema,
]);
//# sourceMappingURL=types.js.map
import { RegistryType } from './IRegistry.js';
import { SynchronousRegistry } from './SynchronousRegistry.js';
import { warpRouteConfigToId } from './warp-utils.js';
const PARTIAL_URI_PLACEHOLDER = '__partial_registry__';
export class PartialRegistry extends SynchronousRegistry {
    type = RegistryType.Partial;
    chainMetadata;
    chainAddresses;
    warpRoutes;
    warpDeployConfigs;
    constructor({ chainMetadata, chainAddresses, warpRoutes, warpDeployConfigs, logger }) {
        super({ uri: PARTIAL_URI_PLACEHOLDER, logger });
        this.chainMetadata = chainMetadata || {};
        this.chainAddresses = chainAddresses || {};
        this.warpRoutes = warpRoutes || [];
        this.warpDeployConfigs = warpDeployConfigs || [];
    }
    listRegistryContent() {
        const chains = {};
        Object.keys(this.chainMetadata).forEach((c) => {
            chains[c] ||= {};
            chains[c].metadata = PARTIAL_URI_PLACEHOLDER;
        });
        Object.keys(this.chainAddresses).forEach((c) => {
            chains[c] ||= {};
            chains[c].addresses = PARTIAL_URI_PLACEHOLDER;
        });
        const warpRoutes = this.warpRoutes.reduce((acc, r) => {
            // Cast is useful because this handles partials and is safe because the fn validates data
            const id = warpRouteConfigToId(r);
            acc[id] = PARTIAL_URI_PLACEHOLDER;
            return acc;
        }, {});
        return {
            chains,
            deployments: {
                warpRoutes,
                warpDeployConfig: {} // TODO: This cannot be implemented without deriving the token symbol from config.token
            },
        };
    }
    getMetadata() {
        return this.chainMetadata;
    }
    getAddresses() {
        return this.chainAddresses;
    }
    removeChain(chainName) {
        super.removeChain(chainName);
        if (this.chainMetadata?.[chainName])
            delete this.chainMetadata[chainName];
        if (this.chainAddresses?.[chainName])
            delete this.chainAddresses[chainName];
    }
    addWarpRoute(_config) {
        throw new Error('Method not implemented.');
    }
    getWarpRoutesForIds(ids) {
        return this.warpRoutes.filter((r) => {
            const id = warpRouteConfigToId(r);
            return ids.includes(id);
        });
    }
    getWarpDeployConfigForIds(_ids) {
        // TODO: Right now this returns an empty array
        // This cannot be implemented without deriving the token symbol from config.token
        // We will revisit once we merge the configs
        return this.warpDeployConfigs;
    }
    createOrUpdateChain(chain) {
        if (chain.metadata)
            this.chainMetadata[chain.chainName] = chain.metadata;
        if (chain.addresses)
            this.chainAddresses[chain.chainName] = chain.addresses;
    }
}

import { stripLeadingSlash } from '../utils.js';
import { MergedRegistry } from './MergedRegistry.js';
export class BaseRegistry {
    uri;
    logger;
    // Caches
    listContentCache;
    metadataCache;
    isMetadataCacheFull = false;
    addressCache;
    isAddressCacheFull = false;
    constructor({ uri, logger }) {
        this.uri = uri;
        // @ts-ignore forcing in to avoid a @hyperlane-xyz/utils
        // dependency here, which could bloat consumer bundles
        // unnecessarily (e.g. they just want metadata)
        this.logger = logger || console;
    }
    getUri(itemPath) {
        if (itemPath)
            itemPath = stripLeadingSlash(itemPath);
        return itemPath ? `${this.uri}/${itemPath}` : this.uri;
    }
    getChainsPath() {
        return 'chains';
    }
    getWarpRoutesPath() {
        return 'deployments/warp_routes';
    }
    getWarpRoutesArtifactPaths({ tokens }, options) {
        if (!tokens.length)
            throw new Error('No tokens provided in config');
        const symbols = new Set(tokens.map((token) => token.symbol.toUpperCase()));
        if (!options?.symbol && symbols.size !== 1)
            throw new Error('Only one token symbol per warp config is supported for now. Consider passing a symbol as a parameter');
        const symbol = options?.symbol || symbols.values().next().value;
        const chains = tokens
            .map((token) => token.chainName)
            .sort()
            .join('-');
        const basePath = `${this.getWarpRoutesPath()}/${symbol}/${chains}`;
        return { configPath: `${basePath}-config.yaml` };
    }
    async getChainLogoUri(chainName) {
        const registryContent = await this.listRegistryContent();
        const chain = registryContent.chains[chainName];
        return chain?.logo ?? null;
    }
    merge(otherRegistry) {
        return new MergedRegistry({ registries: [this, otherRegistry], logger: this.logger });
    }
}

import type { Logger } from 'pino';
import type { ChainMap, ChainMetadata, ChainName, WarpCoreConfig, WarpRouteDeployConfig } from '@hyperlane-xyz/sdk';
import { ChainAddresses, WarpDeployConfigMap, WarpRouteConfigMap, WarpRouteId } from '../types.js';
import { AddWarpRouteOptions, IRegistry, RegistryContent, RegistryType, UpdateChainParams, WarpRouteFilterParams } from './IRegistry.js';
export interface MergedRegistryOptions {
    registries: Array<IRegistry>;
    logger?: Logger;
}
/**
 * A registry that accepts multiple sub-registries.
 * Read methods are performed on all sub-registries and the results are merged.
 * Write methods are performed on all sub-registries.
 * Can be created manually or by calling `.merge()` on an existing registry.
 */
export declare class MergedRegistry implements IRegistry {
    readonly type = RegistryType.Merged;
    readonly uri = "__merged_registry__";
    readonly registries: Array<IRegistry>;
    protected readonly logger: Logger;
    constructor({ registries, logger }: MergedRegistryOptions);
    getUri(): string;
    listRegistryContent(): Promise<RegistryContent>;
    getChains(): Promise<Array<ChainName>>;
    getMetadata(): Promise<ChainMap<ChainMetadata>>;
    getChainMetadata(chainName: ChainName): Promise<ChainMetadata | null>;
    getAddresses(): Promise<ChainMap<ChainAddresses>>;
    getChainAddresses(chainName: ChainName): Promise<ChainAddresses | null>;
    getChainLogoUri(chainName: ChainName): Promise<string | null>;
    addChain(chain: UpdateChainParams): Promise<void>;
    updateChain(chain: UpdateChainParams): Promise<void>;
    removeChain(chain: ChainName): Promise<void>;
    getWarpRoute(id: WarpRouteId): Promise<WarpCoreConfig | null>;
    getWarpDeployConfig(id: WarpRouteId): Promise<WarpRouteDeployConfig | null>;
    getWarpRoutes(filter?: WarpRouteFilterParams): Promise<WarpRouteConfigMap>;
    getWarpDeployConfigs(filter?: WarpRouteFilterParams): Promise<WarpDeployConfigMap>;
    addWarpRoute(config: WarpCoreConfig, options?: AddWarpRouteOptions): Promise<void>;
    protected multiRegistryRead<R>(readFn: (registry: IRegistry) => Promise<R> | R): Promise<(Awaited<R> | Awaited<R>)[]>;
    protected multiRegistryWrite(writeFn: (registry: IRegistry) => Promise<void>, logMsg: string): Promise<void>;
    merge(otherRegistry: IRegistry): IRegistry;
}

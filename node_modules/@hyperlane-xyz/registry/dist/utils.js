import { stringify } from 'yaml';
import { ABACUS_WORKS_DEPLOYER_NAME } from './consts.js';
export function toYamlString(data, prefix) {
    const yamlString = stringify(data, { indent: 2, sortMapEntries: true, aliasDuplicateObjects: false });
    return prefix ? `${prefix}\n${yamlString}` : yamlString;
}
export function stripLeadingSlash(path) {
    return path.startsWith('/') || path.startsWith('\\') ? path.slice(1) : path;
}
export async function concurrentMap(concurrency, xs, mapFn) {
    let res = [];
    for (let i = 0; i < xs.length; i += concurrency) {
        const remaining = xs.length - i;
        const sliceSize = Math.min(remaining, concurrency);
        const slice = xs.slice(i, i + sliceSize);
        res = res.concat(await Promise.all(slice.map((elem, index) => mapFn(elem, i + index))));
    }
    return res;
}
export function isObject(item) {
    return item && typeof item === 'object' && !Array.isArray(item);
}
// Recursively merges b into a
// Where there are conflicts, b takes priority over a
export function objMerge(a, b, max_depth = 10) {
    if (max_depth === 0) {
        throw new Error('objMerge tried to go too deep');
    }
    if (isObject(a) && isObject(b)) {
        const ret = {};
        const aKeys = new Set(Object.keys(a));
        const bKeys = new Set(Object.keys(b));
        const allKeys = new Set([...aKeys, ...bKeys]);
        for (const key of allKeys.values()) {
            if (aKeys.has(key) && bKeys.has(key)) {
                ret[key] = objMerge(a[key], b[key], max_depth - 1);
            }
            else if (aKeys.has(key)) {
                ret[key] = a[key];
            }
            else {
                ret[key] = b[key];
            }
        }
        return ret;
    }
    else {
        return b ? b : a;
    }
}
export function isAbacusWorksChain(metadata) {
    return metadata.deployer?.name?.toLowerCase() === ABACUS_WORKS_DEPLOYER_NAME.toLowerCase();
}
